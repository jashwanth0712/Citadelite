import {
  logger_default
} from "./chunk-IBGL6YYT.mjs";

// src/store/createMicSlice.ts
var createMicSlice = (set, get) => ({
  micState: {
    mediaDevice: null,
    stream: null,
    streamError: null,
    deviceLoading: true
  },
  audioDevices: [],
  enableAudioStream: async () => {
    var _a;
    if (get().micState.stream) {
      logger_default.error({
        type: "error",
        msg: "createMediaSlice.enableStream() | No stream"
      });
      return;
    }
    const deviceEnabledConstrains = {
      audio: {
        deviceId: (_a = get().micState.mediaDevice) == null ? void 0 : _a.deviceId
      }
    };
    logger_default.info("Enabling new Mic stream");
    await navigator.mediaDevices.getUserMedia(deviceEnabledConstrains).then((_stream) => {
      set(() => ({
        micState: {
          ...get().micState,
          stream: _stream,
          deviceLoading: false
        }
      }));
    }).catch((_error) => {
      set(() => ({
        micState: {
          ...get().micState,
          streamError: {
            type: _error.name,
            blocked: _error.name === "NotAllowedError"
          },
          deviceLoading: false
        }
      }));
    });
    navigator.mediaDevices.ondevicechange = () => {
      get().getAudioDevices();
    };
    if (!get().micState.mediaDevice) {
      const audioDevices = await get().getAudioDevices();
      logger_default.info({ audioDevices });
      get().setAudioDevice(audioDevices[0]);
    }
  },
  getAudioDevices: async () => {
    const { setAudioStreamError } = get();
    try {
      const mediaDevices = await navigator.mediaDevices.enumerateDevices();
      const devices = mediaDevices.filter(({ kind }) => kind === "audioinput");
      set(() => ({
        audioDevices: devices
      }));
      return devices;
    } catch (err) {
      setAudioStreamError(err == null ? void 0 : err.name);
      return [];
    }
  },
  setAudioDevice: (device) => {
    set(() => ({
      micState: {
        ...get().micState,
        mediaDevice: device
      }
    }));
  },
  switchAudioStream: (stream) => {
    logger_default.info({
      type: "info",
      msg: "switchAudioStream() | Switching A stream"
    });
    if (!stream) {
      logger_default.info({
        type: "info",
        msg: "switchAudioStream() | No stream Found using default Stream"
      });
      return;
    }
    get().pauseAudioTracks();
    get().setAudioStream(stream);
  },
  setAudioStream: (stream) => {
    logger_default.info({
      type: "info",
      msg: "setAudioStream() | Setting Audio stream",
      stream
    }), set(() => ({
      micState: {
        ...get().micState,
        stream
      }
    }));
  },
  pauseAudioTracks: () => {
    const { stream } = get().micState;
    if (!stream)
      return;
    logger_default.info({
      type: "info",
      msg: "pauseAudioTracks() | Pausing Audio stream"
    });
    stream.getTracks().forEach((track) => track.stop());
    set(() => ({ micState: { ...get().micState, stream: null } }));
  },
  setAudioDeviceLoading: (loading) => {
    set(() => ({ micState: { ...get().micState, deviceLoading: loading } }));
  },
  setAudioStreamError: (error) => {
    set(() => ({
      micState: {
        ...get().micState,
        streamError: {
          type: error || "UnknownError",
          blocked: error === "NotAllowedError"
        }
      }
    }));
  }
});
var createMicSlice_default = createMicSlice;

export {
  createMicSlice_default
};
