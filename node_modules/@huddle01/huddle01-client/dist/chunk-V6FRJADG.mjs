import {
  RoomMediasoupClient
} from "./chunk-3H3TPHFB.mjs";
import {
  getDeviceType
} from "./chunk-DEIMBSB5.mjs";
import {
  triggerIframeEvent
} from "./chunk-XTYRZSMP.mjs";
import {
  disableFigment
} from "./chunk-E3J4KYLN.mjs";
import {
  WEBCAM_SIMULCAST_ENCODINGS
} from "./chunk-SQKZRIEU.mjs";
import {
  logger_default
} from "./chunk-IBGL6YYT.mjs";

// src/HuddleClient/HuddleClient.ts
import axios from "axios";
var HuddleClient = class extends RoomMediasoupClient {
  constructor(peerId, isBot, apiKey) {
    super(apiKey);
    this.joining = false;
    this.roomId = null;
    this.hostId = null;
    this.peerId = peerId;
    this.produce = true;
    this._webcamProducer = null;
    this._shareVideoProducer = null;
    this._shareAudioProducer = null;
    this.micProducer = null;
    this._loading = false;
    this._chatDataProducer = null;
    this._useDataChannel = true;
    this._bot = isBot;
  }
  get isBot() {
    return this._bot;
  }
  async changeAvatarUrl(avatarUrl) {
    if (!this.socket)
      return logger_default.error({
        type: "error",
        message: "changeAvatarUrl",
        error: "no socket"
      });
    try {
      this.setMeAvatarUrl(avatarUrl);
      await this.socket.request("changeAvatarUrl", { avatarUrl });
    } catch (error) {
      console.error(error);
    }
  }
  async sendDM(message, toId, fromId) {
    var _a;
    const _time = new Date();
    try {
      await ((_a = this.socket) == null ? void 0 : _a.request("sendData", {
        type: "dm",
        payload: { message, toId, fromId, timestamp: _time.toISOString() }
      }));
    } catch (error) {
      console.error(error);
    }
  }
  async toggleRaiseHand(isHandRaised) {
    var _a;
    try {
      await ((_a = this.socket) == null ? void 0 : _a.request("sendData", {
        type: "raiseHand",
        payload: { isHandRaised }
      }));
      this.toggleMeHandRaise(isHandRaised);
    } catch (error) {
      console.error(error);
    }
  }
  async sendReaction(reaction) {
    var _a;
    try {
      await ((_a = this.socket) == null ? void 0 : _a.request("sendData", {
        type: "reaction",
        payload: { reaction }
      }));
      this.addMeReaction(reaction);
    } catch (error) {
      console.error(error);
    }
  }
  async allowLobbyPeerToJoinRoom(peerIdToAdmit) {
    if (!this.socket)
      return;
    this.socket.request("allowRoomJoin", { peerIdToAdmit });
  }
  async allowAllLobbyPeersToJoinRoom() {
    if (!this.socket)
      return;
    this.socket.request("admitAll");
  }
  async disallowLobbyPeerFromJoiningRoom(peerIdToDisallow) {
    if (!this.socket)
      return;
    this.socket.request("disallowRoomJoin", {
      peerIdToDisallow
    });
  }
  async disallowAllLobbyPeerFromJoiningRoom() {
    if (!this.socket)
      return;
    this.socket.request("denyAll");
  }
  async requestLobby(displayName, avatarUrl, walletData) {
    if (!this.socket)
      return logger_default.error({ type: "error", msg: "no socket" });
    const geoLocation = this.getUserGeoLocation();
    const userData = {
      displayName,
      avatarUrl,
      geoLocation
    };
    const { host, hostState } = await this.socket.request("lobby", {
      userData,
      walletData
    });
    this.setHostState(hostState);
    logger_default.info({
      type: "info",
      msg: "requestLobby()",
      data: { host, meId: this.peerId }
    });
    this.hostId = host;
  }
  async join(roomId, walletData) {
    if (this.joining)
      return;
    this.joining = true;
    this.setSocket(roomId, this.peerId);
    if (!this.socket)
      return logger_default.error({ type: "error", msg: "join() no socket" });
    this.socket.on("open", async () => {
      logger_default.info({ type: "info", msg: "socket open" });
      const avatarUrl = this.getAvatarUrl();
      await this.requestLobby(this.getDisplayName(), avatarUrl, walletData);
      this.initMe({
        peerId: this.peerId,
        displayName: this.getDisplayName(),
        avatarUrl
      });
      this.roomId = roomId;
    });
    this.socket.on("failed", () => {
      logger_default.info({
        type: "error",
        text: "WebSocket connection failed/ Wrong API Key"
      });
    });
    this.socket.on("disconnected", () => {
      logger_default.info({
        type: "error",
        text: "WebSocket  disconnected"
      });
    });
    this.socket.on("close", () => {
      var _a, _b;
      logger_default.info({ type: "error", text: "WebSocket  closed" });
      (_a = this.recvTransport) == null ? void 0 : _a.close();
      (_b = this.sendTransport) == null ? void 0 : _b.close();
      this.disableCamStream();
    });
    this.socket.on("request", async (request, accept, _reject) => {
      var _a;
      const promises = [];
      const requestMethods = {
        newConsumer: async () => {
          logger_default.info({ type: "info", msg: "newConsumer", data: request.data });
          const {
            peerId,
            producerId,
            id,
            kind,
            rtpParameters,
            appData,
            producerPaused
          } = request.data;
          if (!this.recvTransport)
            return;
          try {
            const consumer = await this.recvTransport.consume({
              id,
              producerId,
              kind,
              rtpParameters,
              appData: { ...appData, peerId }
            });
            this.consumers.set(consumer.id, consumer);
            consumer.on("transportclose", () => {
              var _a2;
              logger_default.info({
                type: "info",
                msg: "consumer transport closed",
                data: {
                  consumerId: consumer.id,
                  peerId: (_a2 = consumer.appData) == null ? void 0 : _a2.peerId
                }
              });
              this.consumers.delete(consumer.id);
              this.removeStreamFromHark(peerId);
            });
            const consumerToAdd = {
              id: consumer.id,
              track: consumer.track,
              isPaused: producerPaused,
              peerId,
              appData
            };
            this.addConsumerMedia(peerId, appData.type, consumerToAdd);
            if (appData.type === "mic") {
              if (consumerToAdd.isPaused) {
                this.pauseConsumerMedia(peerId, appData.type);
              } else
                this.addStreamToHark(consumer.track, peerId);
            }
            if (appData.type === "share") {
              logger_default.info({
                type: "info",
                msg: "newConsumer | Screen Share Enabled",
                peerId
              });
              this.enableScreenShare(peerId);
            }
            if (appData.type === "shareAudio") {
              logger_default.info({
                type: "info",
                msg: "newConsumer | Screenshare Audio Share Enabled",
                peerId
              });
            }
            accept();
            if (appData.type === "cam" && this.getBandwidthSaver()) {
              promises.push(this.pauseConsumer(id, peerId, "cam"));
            }
          } catch (error) {
            logger_default.error({ type: error, error });
            promises.splice(0, promises.length);
          }
        }
      };
      await ((_a = requestMethods[request.method]) == null ? void 0 : _a.call(requestMethods));
      await Promise.all(promises);
    });
    this.socket.on("notification", (notification) => {
      var _a;
      const notifMethods = {
        peerAvatarUrlChanged: () => {
          logger_default.info({ type: "info", msg: "peerAvatarUrlChanged" });
          const { peerId, avatarUrl } = notification.data;
          triggerIframeEvent("avatar-url-changed", {
            peerId,
            avatarUrl
          });
          this.changePeerAvatarUrl(peerId, avatarUrl);
        },
        joinRoomPermissionGranted: () => {
          logger_default.info({ type: "info", msg: "joinRoomPermissionGranted" });
          this.joinRoom();
        },
        joinRoomPermissionDenied: () => {
          this.close("denied");
          logger_default.info({ type: "info", msg: "joinRoomPermissionDenied" });
        },
        roomClosedByHost: () => {
          this.close("closedByHost");
          logger_default.info({ type: "info", msg: "roomClosedByHost" });
        },
        kickedByHost: () => {
          this.close("kicked");
          logger_default.info({ type: "info", msg: "kickedByHost" });
        },
        newLobbyPeer: () => {
          const data = notification.data;
          this.addLobbyPeer(data.lobbyPeers);
          logger_default.info({
            type: "info",
            msg: "newLobbyPeer",
            data: notification.data
          });
        },
        newPeer: () => {
          const peer = notification.data;
          if (peer.id === "recorder_bot") {
            logger_default.info({
              type: "info",
              message: "Recorder Bot has entered the room...",
              meta: {
                peerId: peer.id
              }
            });
            return;
          }
          const newPeer = {
            peerId: peer.id,
            displayName: peer.displayName,
            avatarUrl: peer.avatarUrl,
            isMicPaused: true,
            isCamPaused: true,
            isSharePaused: true,
            isHandRaised: false,
            reaction: peer.reaction
          };
          triggerIframeEvent("peer-join", newPeer);
          this.setScreenShareLayout(this.isBot, "sideBarGridView");
          this.addPeer(peer.id, newPeer);
          this.addPeerPort(peer.id);
          if (this.getSpaceLeftInViewport() > 0)
            this.addPeerViewPort(peer.id);
          logger_default.info({
            type: "info",
            msg: "newPeer",
            data: notification.data
          });
          this.setNotificationSounds("peerJoin");
        },
        peerClosed: () => {
          const { peerId } = notification.data;
          if (peerId === "recorder_bot")
            return;
          this.removeChat(peerId);
          this.removePeerViewPort(peerId);
          if (this.getSpaceLeftInViewport() > 0 && this.isLastNActive()) {
            this.deactivateLastN();
          }
          this.removePeerPort(peerId);
          this.removePeer(peerId);
          this.setScreenShareLayout(this.isBot, "sideBarView");
          triggerIframeEvent("peer-left", { peerId });
          logger_default.info({
            type: "info",
            msg: "peerClosed",
            data: notification.data
          });
          this.setNotificationSounds("peerLeave");
          this.removeStreamFromHark(peerId);
        },
        updatedPeersArray: () => {
          const data = notification.data;
          this.addLobbyPeer(data.lobbyPeers);
          logger_default.info({
            type: "info",
            msg: "updatedPeersArray",
            data: notification.data
          });
        },
        consumerClosed: () => {
          const { consumerId } = notification.data;
          const consumer = this.consumers.get(consumerId);
          logger_default.info({ type: "info", msg: "consumerClosed", consumer });
          if (!consumer)
            return;
          const {
            appData: { type, peerId }
          } = consumer;
          if (type === "share") {
            logger_default.info({
              type: "info",
              msg: "newConsumer | Screen Share Disabled",
              peerId
            });
            this.disableScreenShare("grid");
          }
          if (type === "mic")
            this.removeStreamFromHark(peerId);
          consumer.close();
          this.consumers.delete(consumerId);
          this.removeConsumerMedia(
            peerId,
            type
          );
        },
        consumerPaused: () => {
          const { consumerId } = notification.data;
          const consumer = this.consumers.get(consumerId);
          if (!consumer)
            return;
          const {
            appData: { type, peerId }
          } = consumer;
          logger_default.info({ type: "info", msg: "consumerPaused", consumer });
          consumer.pause();
          if (type === "mic") {
            this.pauseConsumerMedia(peerId, type);
            this.removeStreamFromHark(peerId);
          }
        },
        consumerResumed: () => {
          const { consumerId } = notification.data;
          const consumer = this.consumers.get(consumerId);
          if (!consumer)
            return;
          const {
            appData: { type, peerId }
          } = consumer;
          logger_default.info({ type: "info", msg: "consumerResumed", consumer });
          consumer.resume();
          if (type === "mic") {
            this.resumeConsumerMedia(peerId, type);
            this.addStreamToHark(consumer.track, peerId);
          }
        },
        "recording-started": () => {
          this.setStartRecording();
          this.toggleRecording(true);
          this.setNotifyRecording("started", true);
          logger_default.info({ type: "info", msg: "recording-started" });
        },
        "recording-stopped": () => {
          this.setStopRecording();
          this.toggleRecording(false);
          this.setNotifyRecording("finished", true);
          logger_default.info({ type: "info", msg: "recording-stopped" });
        },
        recordingUrl: () => {
          const { s3URL, ipfsURL, size, duration, uploadToIpfs } = notification.data;
          logger_default.info({
            type: "info",
            msg: "recording-stopped",
            s3URL,
            ipfsURL,
            uploadToIpfs
          });
          this.updateRecording({
            url: s3URL,
            duration,
            size,
            uploadToIpfs: !!uploadToIpfs
          });
        },
        getAllRecordings: () => {
          const recordingURls = notification.data;
          logger_default.info("Got all recordings");
          logger_default.info({ recordingURls });
          this.setRecordings(recordingURls);
        },
        "disabled-last-N": () => {
          const peerIds = this.getPeerIds();
          logger_default.info({
            type: "info",
            msg: "disabled-last-N",
            meta: {
              peerIds
            }
          });
          if (this.isLastNActive())
            this.deactivateLastN();
        },
        "updated-last-N": () => {
          const { lastNPeers, mostInactivePeerIdInLastN } = notification.data;
          const meId = this.peerId;
          const lastNArr = lastNPeers.includes(meId) ? lastNPeers.filter((peerId) => peerId !== meId) : lastNPeers.filter(
            (peerId) => mostInactivePeerIdInLastN ? peerId !== mostInactivePeerIdInLastN : lastNPeers[lastNPeers.length - 1] !== peerId
          );
          logger_default.info({
            type: "info",
            msg: "updated-last-N | Updaing with new lastNPeers"
          });
          if (!this.isLastNActive())
            this.activateLastN();
          this.setActiveViewPort(lastNArr);
        },
        "updated-network-strength": () => {
          const { networkStrength } = notification.data;
          this.setNetworkStats(networkStrength);
        },
        receiveData: () => {
          const { type, payload } = notification.data;
          if (type === "dm") {
            const { toId, fromId, message, timestamp } = payload;
            if (toId === "mainRoom") {
              this.setChat(message, "mainRoom", fromId, timestamp);
              if (fromId !== this.peerId)
                this.increaseUnread("mainRoom");
            } else {
              const swappedId = fromId;
              this.setChat(message, swappedId, fromId, timestamp);
              this.increaseUnread(fromId);
            }
            if (fromId !== this.peerId) {
              this.setNotificationSounds("chat");
            }
          }
          if (type === "reaction") {
            const { peerId, reaction } = payload;
            if (this.peerId !== peerId)
              this.addReaction(peerId, reaction);
          }
          if (type === "raiseHand") {
            const { peerId, isHandRaised } = payload;
            this.togglePeerHandRaise(peerId, isHandRaised);
          }
          if (type === "sharedFile") {
            const _time = new Date();
            const { peerId, fileDetails } = payload;
            this.addSharedFile(fileDetails);
            this.setChat(
              "I've shared a file, please check it out from shared files tab.",
              "mainRoom",
              peerId,
              _time.toISOString()
            );
            this.increaseUnread("mainRoom");
          }
        },
        enabledHostControls: () => {
          const { type } = notification.data;
          const enableHostControlFuncs = {
            enableHostOnlyVideo: () => {
              this.setSingleHostControl("allowVideo", false);
            },
            enableHostOnlyAudio: () => {
              this.setSingleHostControl("allowAudio", false);
            },
            enableHostOnlyScreenShare: () => {
              this.setSingleHostControl("allowScreenShare", false);
            },
            enableHostOnlyChat: () => {
              this.setSingleHostControl("allowChat", false);
            }
          };
          enableHostControlFuncs[type]();
        },
        disabledHostControls: () => {
          const { type } = notification.data;
          const disableHostControlFuncs = {
            disableHostOnlyVideo: () => {
              this.setSingleHostControl("allowVideo", true);
            },
            disableHostOnlyAudio: () => {
              this.setSingleHostControl("allowAudio", true);
            },
            disableHostOnlyScreenShare: () => {
              this.setSingleHostControl("allowScreenShare", true);
            },
            disableHostOnlyChat: () => {
              this.setSingleHostControl("allowChat", true);
            }
          };
          disableHostControlFuncs[type]();
        },
        hostIs: () => {
          const { hostId } = notification.data;
          logger_default.info({ type: "info", msg: "hostIs" });
          this.setHost(hostId);
        },
        updatedCoHosts: () => {
          const { coHosts } = notification.data;
          logger_default.info({ type: "info", msg: "updatedCoHosts" });
          this.setCoHosts(coHosts);
        },
        muteMe: () => {
          this.muteMic();
        },
        disableMyCam: () => {
          this.disableWebcam();
        },
        stopScreenShare: () => {
          this.disableShare();
        },
        streamStarted: () => {
          const { stream, platform } = notification.data;
          logger_default.info("stream started", { stream });
          if (stream.id) {
            const streamData = {
              isLive: true,
              isLoading: false,
              url: `https://livepeer.huddle01.com/livestream?streamId=${stream.id}`
            };
            this.setStreamData(platform, streamData);
            this.setStreamPlatform(platform);
          }
        },
        streamStopped: () => {
          const { platform } = notification.data;
          logger_default.info("stream started");
          this.stopStreaming(platform);
        },
        recordingOrStreamingError: () => {
          const { type } = notification.data;
          if (type == "record") {
            this.setRecordingEnded();
          }
          if (type == "stream") {
            this.stopStreaming("livepeer");
          }
        },
        "room-lock-state": () => {
          const { isRoomLocked } = notification.data;
          this.setRoomLockState(isRoomLocked);
        },
        downlinkBwe: () => {
          logger_default.info("downlinkBwe event :", notification.data);
        }
      };
      (_a = notifMethods[notification.method]) == null ? void 0 : _a.call(notifMethods);
    });
  }
  async joinRoom() {
    if (!this.socket)
      return;
    try {
      await this.loadMediasoupDevice();
      if (!this.mediasoupDevice)
        return;
      try {
        const { data: turn } = await axios.get(
          "https://jbzp43rb25.execute-api.ap-south-1.amazonaws.com/turn"
        );
        const turnServers = turn.servers;
        const fixedTurnServers = turnServers.map(({ url, ...rest }) => ({
          ...rest,
          urls: url
        }));
        this._turn = fixedTurnServers || [];
      } catch (err) {
        logger_default.error("error fetching turn servers", err);
      }
      if (!this.isBot)
        await this.createSendTransport();
      await this.createRecvTransport();
      const joinedData = await this.socket.request("join", {
        displayName: this.getDisplayName(),
        rtpCapabilities: this.mediasoupDevice.rtpCapabilities,
        sctpCapabilities: this.mediasoupDevice.sctpCapabilities,
        avatarUrl: this.getAvatarUrl(),
        device: {
          device: getDeviceType(),
          name: this.mediasoupDevice.handlerName
        }
      });
      const {
        peers,
        roomId,
        hostId,
        coHostIds,
        createdAt,
        isRoomLocked,
        isRecordingOrStreaming,
        typeOfStreamingOrRecording,
        streamId,
        sharedFiles,
        hostControls,
        streamingPlatform
      } = joinedData;
      peers.forEach((peer) => {
        if (peer.id !== "recorder_bot") {
          const newPeer = {
            peerId: peer.id,
            displayName: peer.displayName,
            avatarUrl: peer.avatarUrl,
            isMicPaused: true,
            isCamPaused: true,
            isSharePaused: true,
            isHandRaised: false,
            reaction: peer.reaction
          };
          this.addPeer(peer.id, newPeer);
          this.addPeerPort(peer.id);
        }
      });
      if (!hostControls.allowVideo) {
        this.toggleProducerMedia("cam", "off");
        await this.disableAllCamStreams();
      }
      if (!this.getProducerState("cam") && hostControls.allowVideo)
        await this.enableWebcam();
      const micPaused = this.isMicPaused();
      await this.enableMic();
      if (!hostControls.allowAudio || micPaused) {
        this.toggleProducerMedia("mic", "off");
        await this.muteMic();
      }
      this.initHostControls(hostId, this.peerId, hostControls, coHostIds);
      this.setRoomId(roomId);
      this.setRoomLockState(isRoomLocked);
      this.setActiveViewPortForNewPeer();
      this.setCreatedAt(createdAt);
      if (streamingPlatform) {
        const streamObj = {
          isLive: true,
          isLoading: false,
          url: `https://livepeer.huddle01.com/livestream?streamId=${streamId}`
        };
        this.setStreamData(streamingPlatform, streamObj);
        this.setStreamPlatform(streamingPlatform);
      }
      this.setSharedFiles(sharedFiles);
      if (isRecordingOrStreaming) {
        if (typeOfStreamingOrRecording == "record") {
          this.toggleRecording(true);
        }
        if (hostId === this.peerId) {
          this.setStartRecording();
        }
      }
      const numOfPeersToSwitchView = this.isBot ? 3 : 2;
      if (this.getPeerIds().length > numOfPeersToSwitchView) {
        this.setLayoutView("sideBarGridView");
      }
      this.setJoined();
    } catch (error) {
      logger_default.error({
        type: "error",
        error,
        message: "Couldn't join room",
        loc: "RoomProvider.tsx -> joinRoom()"
      });
    }
  }
  async enableWebcam(figmentDisable = true) {
    const isCamPaused = this.getProducerState("cam");
    const regex = /([da-z.-]+).huddle01.com$/;
    const isHuddleApp = regex.test(window.location.hostname);
    console.log({ isHuddleApp });
    try {
      if (isCamPaused && figmentDisable || !isHuddleApp) {
        console.log("ldaaa");
        this.disableCamStream();
        await this.enableCamStream();
        console.log("2ldaaa");
      }
      const stream = this.getCamStream();
      if (!stream) {
        logger_default.error({
          type: "error",
          msg: "enableWebcam() | No Stream Enabled"
        });
        return;
      }
      if (!this.sendTransport)
        return;
      const track = stream.getVideoTracks()[0];
      let encodings;
      const codecOptions = {
        videoGoogleStartBitrate: 1e3
      };
      const useSimulcast = true;
      if (useSimulcast) {
        encodings = WEBCAM_SIMULCAST_ENCODINGS;
      }
      this._webcamProducer = await this.sendTransport.produce({
        track,
        encodings,
        codecOptions,
        appData: {
          type: "cam",
          share: false
        }
      });
      const webcamProd = {
        id: this._webcamProducer.id,
        track: this._webcamProducer.track,
        isPaused: false,
        peerId: this.peerId,
        appData: { type: "cam", peerId: this.peerId }
      };
      this.addProducerMedia("cam", webcamProd);
      logger_default.info({
        type: "info",
        msg: "enableWebcam",
        webcamProducer: this._webcamProducer
      });
      this._webcamProducer.on("transportclose", async () => {
        logger_default.info({
          type: "info",
          msg: "enableWebcam | transportclose",
          webcamProducer: this._webcamProducer
        });
        this.removeProducerMedia("cam");
        this.toggleFigmentStream("disable");
        await disableFigment();
        this._webcamProducer = null;
      });
      this._webcamProducer.on("trackended", async () => {
        logger_default.info({
          type: "info",
          msg: "enableWebcam | trackended",
          webcamProducer: this._webcamProducer
        });
        logger_default.info({
          type: "error",
          text: "Webcam disconnected!"
        });
        this.disableWebcam().catch(() => {
        });
      });
      logger_default.info({
        type: "info",
        msg: "Webcam enabled",
        webcamProducer: this._webcamProducer
      });
    } catch (error) {
      logger_default.error({ type: "error", error });
    }
  }
  async disableWebcam(figmentDisable = true) {
    var _a;
    if (!this.socket) {
      this.disableCamStream();
      logger_default.debug({ type: "debug", msg: "disableWebcam() | No socket" });
      return;
    }
    if (!this._webcamProducer) {
      logger_default.info({ type: "info", msg: "disableWebcam | No Producer" });
      return;
    }
    logger_default.info("webcamProducer is on");
    (_a = this._webcamProducer.track) == null ? void 0 : _a.stop();
    this._webcamProducer.close();
    this.removeProducerMedia("cam");
    try {
      await this.socket.request("closeProducer", {
        producerId: this._webcamProducer.id
      });
      this._webcamProducer = null;
      if (figmentDisable) {
        this.toggleFigmentStream("disable");
        await disableFigment();
        logger_default.info({
          type: "info",
          msg: "disableWebcam | figment disabled"
        });
      }
      this.disableCamStream();
      const stream = this.getCamStream();
      if (stream) {
        logger_default.info({
          type: "info",
          msg: "disableWebcam | stream Still Enabled",
          stream
        });
      }
      logger_default.info("server closed producer");
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error closing server-side webcam Producer: ${error}`
      });
    }
  }
  async changeWebcam(mediaDevice) {
    if (this._loading)
      return;
    this._loading = true;
    if (mediaDevice) {
      this.setMediaDevice(mediaDevice);
    }
    try {
      await this.disableWebcam();
      await this.enableWebcam();
    } catch (error) {
      logger_default.error({ type: "error", msg: "changeWebcam()", error });
    }
    this._loading = false;
  }
  async pauseVideo() {
    logger_default.info({
      msg: "pauseVideo()",
      _webcamProducer: this._webcamProducer,
      this: this
    });
    if (!this.socket)
      return;
    this.produce = false;
    if (!this._webcamProducer)
      return;
    this._webcamProducer.pause();
    try {
      await this.socket.request("pauseProducer", {
        producerId: this._webcamProducer.id
      });
      if (this._webcamProducer !== null)
        this.removeProducerMedia("cam");
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error pausing server-side webcam Producer: ${error}`
      });
    }
  }
  async disableMic() {
    if (!this.micProducer || !this.socket)
      return;
    this.micProducer.close();
    logger_default.info({
      type: "info",
      text: `disableMic()`
    });
    this.removeStreamFromHark(this.peerId);
    try {
      await this.socket.request("closeProducer", {
        producerId: this.micProducer.id
      });
      this.removeProducerMedia("mic");
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error closing server-side mic Producer: ${error}`
      });
    }
    this.micProducer = null;
  }
  async enableMic() {
    if (!this.mediasoupDevice || !this.sendTransport)
      return;
    try {
      this.disableMicStream();
      this.removeStreamFromHark(this.peerId);
      await this.enableMicStream();
      const stream = this.getMicStream();
      logger_default.info({ micstream: stream });
      if (!stream) {
        logger_default.error({
          type: "error",
          msg: "enableMic() | No Stream Enabled"
        });
        return;
      }
      const track = stream.getAudioTracks()[0];
      track.onended = async () => {
        logger_default.error({
          type: "error",
          msg: "enableMic() | track ended"
        });
        await this.disableMic().catch(() => {
        });
      };
      this.addStreamToHark(track, this.peerId);
      this.micProducer = await this.sendTransport.produce({
        track,
        appData: {
          type: "mic",
          share: false
        }
      });
      const micProd = {
        id: this.micProducer.id,
        track: this.micProducer.track,
        isPaused: false,
        peerId: this.peerId,
        appData: { type: "mic", peerId: this.peerId }
      };
      if (this.micProducer !== null)
        this.addProducerMedia("mic", micProd);
      this.micProducer.on("transportclose", () => {
        this.micProducer = null;
      });
      this.micProducer.on("trackended", async () => {
        logger_default.info({
          type: "error",
          text: "Microphone disconnected!"
        });
        try {
          await this.disableMic();
          await this.enableMic();
        } catch (error) {
          alert(
            "error in switching audio input sources, please refresh your tab"
          );
        }
      });
    } catch (error) {
      logger_default.error({ type: "error | enableMic() ", error });
    }
  }
  async changeMic(audioDevice) {
    if (this._loading)
      return;
    this._loading = true;
    if (audioDevice) {
      this.setAudioDevice(audioDevice);
    }
    try {
      await this.disableMic();
      await this.enableMic();
      await this.unmuteMic();
    } catch (error) {
      logger_default.error({ type: "error", msg: "changeMic()", error });
    } finally {
      this._loading = false;
    }
  }
  async muteMic() {
    logger_default.info({
      msg: "muteMic()",
      this: this
    });
    if (!this.socket)
      return;
    if (!this.micProducer)
      return;
    this.micProducer.pause();
    try {
      await this.socket.request("pauseProducer", {
        producerId: this.micProducer.id
      });
      if (this.micProducer !== null)
        this.toggleProducerMedia("mic", "off");
    } catch (error) {
      logger_default.info("muteMic() | failed: %o", error);
    }
  }
  async unmuteMic() {
    logger_default.info({
      msg: "unmuteMic()",
      this: this
    });
    if (!this.socket) {
      logger_default.info("unmuteMic() | no socket");
      return;
    }
    if (!this.micProducer) {
      logger_default.info({
        type: "info",
        msg: "unmuteMic() | micProducer is null enabling mic"
      });
      await this.enableMic();
      return;
    }
    this.micProducer.resume();
    try {
      await this.socket.request("resumeProducer", {
        producerId: this.micProducer.id
      });
      if (this.micProducer !== null)
        this.toggleProducerMedia("mic", "on");
    } catch (error) {
      logger_default.info("unmuteMic() | failed: %o", error);
    }
  }
  async enableShare() {
    if (!this.mediasoupDevice || !this.sendTransport) {
      logger_default.error("enableShare() | cannot produce audio");
      return;
    }
    if (!this.mediasoupDevice.canProduce("video")) {
      logger_default.error("enableShare() | cannot produce video");
      return;
    }
    let track = null;
    let audioTrack = null;
    try {
      let constraints = {
        video: {
          displaySurface: "monitor",
          logicalSurface: true,
          cursor: true,
          width: { max: 1920 },
          height: { max: 1080 },
          frameRate: { max: 30 }
        },
        audio: {
          echoCancellation: true,
          noiseSuppression: true
        }
      };
      const stream = await navigator.mediaDevices.getDisplayMedia(constraints);
      track = stream.getVideoTracks()[0];
      audioTrack = stream.getAudioTracks()[0];
      this._shareVideoProducer = await this.sendTransport.produce({
        track,
        appData: {
          type: "share",
          share: true
        }
      });
      if (audioTrack) {
        this._shareAudioProducer = await this.sendTransport.produce({
          track: audioTrack,
          appData: {
            type: "shareAudio",
            share: true
          }
        });
      }
      const shareProd = {
        id: this._shareVideoProducer.id,
        peerId: this.peerId,
        track: this._shareVideoProducer.track,
        isPaused: this._shareVideoProducer.paused,
        appData: { type: "share", peerId: this.peerId }
      };
      if (this._shareVideoProducer !== null)
        this.addProducerMedia("share", shareProd);
      if (this._shareAudioProducer !== null) {
        const shareAudioProd = {
          id: this._shareAudioProducer.id,
          peerId: this.peerId,
          track: this._shareAudioProducer.track,
          isPaused: this._shareAudioProducer.paused,
          appData: { type: "shareAudio", peerId: this.peerId }
        };
        this.addProducerMedia("shareAudio", shareAudioProd);
        logger_default.info({
          type: "info",
          msg: "Share Audio enabled",
          shareVideoProducer: this._shareAudioProducer,
          shareAudioProd
        });
      }
      this._shareVideoProducer.on("transportclose", async () => {
        await this.disableShare();
      });
      this._shareVideoProducer.on("trackended", async () => {
        logger_default.info({
          type: "error",
          text: "shareScreen Disconnected!"
        });
        try {
          await this.disableShare();
        } catch (error) {
          alert(
            "error in switching audio input sources, please refresh your tab"
          );
        }
      });
      logger_default.info({
        type: "info",
        msg: "Share enabled",
        shareProducer: this._shareVideoProducer
      });
      this.enableScreenShare(this.peerId);
    } catch (error) {
      if (track) {
        track.stop();
        this.disableScreenShare("grid");
      }
      logger_default.error({ type: "error", error });
    }
  }
  async disableShare() {
    if (!this._shareVideoProducer || !this.socket)
      return;
    this._shareVideoProducer.close();
    this.removeProducerMedia("share");
    if (this._shareAudioProducer !== null) {
      this._shareAudioProducer.close();
      this.removeProducerMedia("shareAudio");
    }
    try {
      await this.socket.request("closeProducer", {
        producerId: this._shareVideoProducer.id
      });
      logger_default.info("closed server side share producer");
      if (this._shareAudioProducer) {
        await this.socket.request("closeProducer", {
          producerId: this._shareAudioProducer.id
        });
        logger_default.info("closed server side audio share producer");
      }
      logger_default.info({
        type: "info",
        msg: "Share disabled",
        shareProducer: this._shareVideoProducer
      });
      this.disableScreenShare("grid");
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error closing server-side share Producer: ${error}`
      });
    }
    this._shareVideoProducer = null;
    this._shareAudioProducer = null;
  }
  async emailRecording(to, url) {
    if (!this.socket)
      return;
    try {
      await this.socket.request("emailRecordingUrl", { to, url });
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error emailing recording url: ${error}`
      });
    }
  }
  async getClientNetworkStats() {
    var _a, _b, _c, _d;
    logger_default.debug("getClientNetworkStats()");
    if (!this.socket)
      return;
    const stats = await this.socket.request("getClientNetworkStats", {
      audioProducerId: ((_a = this.micProducer) == null ? void 0 : _a.id) || "",
      videoProducerId: ((_b = this._webcamProducer) == null ? void 0 : _b.id) || "",
      sendTransportId: ((_c = this.sendTransport) == null ? void 0 : _c.id) || "",
      recvTransportId: ((_d = this.recvTransport) == null ? void 0 : _d.id) || ""
    });
    logger_default.info({ stats });
    return stats;
  }
  async handleEnableHostControl(control, controlType) {
    if (!this.socket)
      return;
    try {
      await this.socket.request("handleEnableHostControl", { control });
      this.setSingleHostControl(controlType, false);
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error enabling host control: ${error}`
      });
    }
  }
  async handleDisableHostControl(control, controlType) {
    if (!this.socket)
      return;
    try {
      logger_default.info("huddlecliend handledisable", { control });
      await this.socket.request("handleDisableHostControl", { control });
      this.setSingleHostControl(controlType, true);
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error disabling host control: ${error}`
      });
    }
  }
  async makeACohost(coHostId) {
    if (!this.socket)
      return;
    try {
      await this.socket.request("makeACoHost", { coHostId });
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error making a cohost: ${error}`
      });
    }
  }
  async removeACohost(coHostId) {
    if (!this.socket)
      return;
    try {
      await this.socket.request("removeACoHost", { coHostId });
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error making a cohost: ${error}`
      });
    }
  }
  async kickPeerFromRoom(peerIdToKick) {
    if (!this.socket)
      return;
    try {
      await this.socket.request("kickPeerFromRoom", { peerIdToKick });
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error kicking peer from room: ${error}`
      });
    }
  }
  async closeRoomForEverybody() {
    if (!this.socket)
      return;
    try {
      await this.socket.request("closeRoomForEverybody");
      this.close();
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error closeRoomForEverybody: ${error}`
      });
    }
  }
  async disablePeerMic(peerId) {
    if (!this.socket)
      return;
    try {
      await this.socket.request("mutePeer", { peerId });
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error mutePeer: ${error}`
      });
    }
  }
  async disablePeerCam(peerId) {
    if (!this.socket)
      return;
    try {
      await this.socket.request("disablePeerCam", { peerId });
    } catch (error) {
      logger_default.error({
        type: "error",
        text: `Error disablePeerCam: ${error}`
      });
    }
  }
  async muteEveryone() {
    if (!this.socket)
      return;
    try {
      await this.socket.request("muteEveryone");
    } catch (error) {
      throw new Error(`Cant mute everyone ${error}`);
    }
  }
  async toggleRoomLock() {
    if (!this.socket)
      return;
    try {
      await this.socket.request("toggleRoomLock", {
        state: !this.getRoomLockState()
      });
    } catch (error) {
      throw new Error(`Cant toggle room lock ${error}`);
    }
  }
  async pauseConsumer(consumerId, peerId, type) {
    if (!this.consumers.has(consumerId) || !this.socket)
      return;
    try {
      const consumer = this.consumers.get(consumerId);
      if (!consumer)
        return;
      this.socket.request("pauseConsumer", { consumerId });
      consumer.pause();
      this.pauseConsumerMedia(peerId, type);
    } catch (err) {
      logger_default.error({ type: "error", text: `Error pausing consumer ${err}` });
    }
  }
  async resumeConsumer(consumerId, peerId, type) {
    if (!this.consumers.has(consumerId) || !this.socket)
      return;
    try {
      const consumer = this.consumers.get(consumerId);
      if (!consumer)
        return;
      this.socket.request("resumeConsumer", { consumerId });
      consumer.resume();
      this.resumeConsumerMedia(peerId, type);
    } catch (err) {
      logger_default.error({ type: "error", text: `Error pausing consumer ${err}` });
    }
  }
  async toggleBandwidthSaver(toggle) {
    const promises = [];
    Object.entries(this.getParticipants()).forEach(([peerId, peer]) => {
      var _a;
      if (peer.consumers && ((_a = peer.consumers.cam) == null ? void 0 : _a.id)) {
        promises.push(
          toggle ? this.pauseConsumer(peer.consumers.cam.id, peerId, "cam") : this.resumeConsumer(peer.consumers.cam.id, peerId, "cam")
        );
      }
    });
    await Promise.all(promises);
  }
  close(dropReason) {
    if (!this.socket)
      return;
    this.setDropState(dropReason || "left");
    this.socket.close();
    triggerIframeEvent("me-left", { peerId: this.peerId });
  }
};

export {
  HuddleClient
};
