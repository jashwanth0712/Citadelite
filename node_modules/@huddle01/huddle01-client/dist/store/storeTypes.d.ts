import { SetState, GetState } from 'zustand';
import { EEnableHostControl, EDisableHostControl } from '../schema/enums/EHostControlType.js';

declare type StoreSlice<T extends object, E extends object = T> = (set: SetState<E extends T ? E : E & T>, get: GetState<E extends T ? E : E & T>) => T;
declare enum MediaConsumerTypesEnum {
    cam = "isCamPaused",
    mic = "isMicPaused",
    share = "isShared"
}
declare type IDeviceSwitch = 'on' | 'off';
declare type MediaConsumerTypes = 'mic' | 'cam' | 'share' | 'shareAudio';
declare type Reaction = '' | '😂' | '😢' | '😦' | '😍' | '🤔' | '👀' | '🙌' | '👍' | '👎' | '🔥' | '🍻' | '🚀' | '🎉' | '❤️' | '💯';
declare type IPeerState = {
    peerId: string;
    displayName: string;
    avatarUrl: string;
    producers: MediaConsumerTracks;
    consumers?: MediaConsumerTracks;
    isMicPaused: boolean;
    isCamPaused: boolean;
    isSharePaused: boolean;
    isHandRaised: boolean;
    reaction: Reaction;
};
declare type IMeInitState = Pick<IPeerState, 'peerId' | 'displayName' | 'avatarUrl'>;
declare type IMeState = Omit<IPeerState, 'consumers'>;
declare type IPeerStoreState = Omit<IPeerState, 'producers'>;
declare type INewPeerState = Omit<IPeerStoreState, 'consumers'>;
declare type IPeerStoreStateKeys = Exclude<keyof IPeerStoreState, 'consumers'>;
declare type IMeStoreStateKeys = Exclude<keyof IMeState, 'producers'>;
declare type MediaConsumerTracks = Record<MediaConsumerTypes, MediaConsumer | undefined>;
interface MediaConsumer {
    id: string;
    track: MediaStreamTrack;
    isPaused: boolean;
    peerId: string;
    appData: {
        type: MediaConsumerTypes;
        peerId: string;
    };
}
declare type GridViewTypes = 'share' | 'grid' | 'spotlight';
interface IGridState {
    gridView: GridViewTypes;
    screenSharePeerId?: string | null;
    setGridView: (gridView: GridViewTypes, peerId?: string) => void;
    enableScreenShare: (peerId: string) => void;
    disableScreenShare: (gridView: GridViewTypes) => void;
}
declare type IPeersState = {
    peers: {
        [peerId: string]: IPeerStoreState;
    };
};
interface IPeerStoreType extends IPeersState {
    peerCount: number;
    increasePeerCount: (value: number) => void;
    decreasePeerCount: (value: number) => void;
    addPeer: (peerId: string, peer: INewPeerState) => void;
    removePeer: (peerId: string) => void;
    addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
    pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
    addReaction: (peerId: string, reaction: Reaction) => void;
    removeReaction: (peerId: string) => void;
    setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
}
declare const MediaConsumerTypesObj: {
    cam: string;
    mic: string;
    share: string;
    shareAudio: string;
};
interface IMeStoreType extends IMeState {
    geo: string;
    initMe: (meInit: IMeInitState) => void;
    setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
    setGeo: (geo: string) => void;
    setAvatarUrl: (avatar: string) => void;
    addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
    removeProducerMedia: (producerType: MediaConsumerTypes) => void;
    updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
    toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
    toggleMeHandRaise: (isHandRaised: boolean) => void;
    addMeReaction: (reaction: Reaction) => void;
    rmMeReaction: () => void;
}
interface ILastNStoreType {
    maxViewPortCount: number;
    activeViewPort: number;
    isLastNActive: boolean;
    lastNPeerIds: string[];
    getTotalNumberOfSwaps: (newLastN: string[]) => number;
    setLastNPeerIds: (lastNPeerIds: string[]) => void;
    addPeerToLastN: (peerId: string) => void;
    removePeerFromLastN: (peerId: string) => void;
    activateLastN: () => void;
    deactivateLastN: () => void;
    addActiveViewPort: (value?: number) => void;
    removeActiveViewPort: (value?: number) => void;
}
interface IRecordingType {
    url: string;
    size: number;
    duration: number;
    uploadToIpfs: boolean;
}
interface IRecordingStoreType {
    recordingState: {
        inProgress: boolean;
        processing: boolean;
        started: boolean;
    };
    uploadToIpfs: boolean;
    recordings: IRecordingType[];
    newRecording: IRecordingType | null;
    notifyRecording: {
        started: boolean;
        finished: boolean;
    };
    startRecording: () => void;
    toggleRecording: (started: boolean) => void;
    stopRecording: () => void;
    updateRecordings: (recording: IRecordingType) => void;
    setRecordings: (recordings: IRecordingType[]) => void;
    removeNewrecording: () => void;
    endRecording: () => void;
    setNotifyRecording: (key: 'started' | 'finished', value: boolean) => void;
}
declare type TMediaDevice = {
    deviceId: string;
    label: string;
};
interface ISpeakerState {
    activeSpeaker: MediaDeviceInfo | null;
    setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
}
interface ITestState {
    isTest: boolean;
    toggleIsTest: () => void;
}
declare type TNetStats = {
    last_updated: number;
    data: {
        [peerId: string]: number;
    };
};
interface INetworkState {
    networkStats: TNetStats;
    bandwidthSaver: boolean;
    setBandwidthSaver: (value: boolean) => void;
    setNetworkStats: (networkStats: TNetStats) => void;
}
declare type IMediErrorType = 'NotAllowedError' | 'NotFoundError' | 'NotReadableError' | 'OverconstrainedError' | 'SecurityError' | 'TypeError' | 'UnknownError' | string;
interface IMediaSlice {
    mediaDevice: MediaDeviceInfo | null;
    stream: MediaStream | null;
    streamError: {
        type: IMediErrorType;
        blocked: boolean;
    } | null;
    deviceLoading: boolean;
    streamsArry: MediaStream[];
    enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setMediaDevice: (device: MediaDeviceInfo) => void;
    getMediaDevices: () => Promise<MediaDeviceInfo[]>;
    setMediaStream: (stream: MediaStream | null) => void;
    pauseTracks: () => void;
    switchMediaStream: (stream: MediaStream | null) => void;
    setDeviceLoading: (loading: boolean) => void;
    setStreamError: (error: IMediErrorType) => void;
}
interface IMicSlice {
    micState: {
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: IMediErrorType;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
    };
    audioDevices: MediaDeviceInfo[];
    enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setAudioDevice: (device: MediaDeviceInfo) => void;
    getAudioDevices: () => Promise<MediaDeviceInfo[]>;
    setAudioStream: (stream: MediaStream | null) => void;
    pauseAudioTracks: () => void;
    switchAudioStream: (stream: MediaStream | null) => void;
    setAudioDeviceLoading: (loading: boolean) => void;
    setAudioStreamError: (error: IMediErrorType) => void;
}
declare type IChatType = 'text' | 'file' | 'video' | 'audio';
declare type IChatErrorType = Pick<IChatMessage, 'error'>;
declare type IChatMessage = {
    id: string;
    peerId: string;
    displayName?: string;
    type: IChatType;
    message?: string;
    timestamp?: string;
    error?: {
        type?: IMediErrorType;
        isError: boolean;
    };
};
declare type IChatText = Omit<IChatMessage, 'id'>;
declare type TSharedFile = {
    fileName: string;
    fileSize: number;
    ipfsHash: string;
    sharedByPeer: string;
};
declare type TNotifSounds = 'chat' | 'peerJoin' | 'peerLeave' | '';
interface IChatStoreType {
    unread: {
        [chatRoomId: string]: number;
    };
    chat: {
        [chatRoomId: string]: IChatMessage[];
    };
    reactions: {
        [peerId: string]: string;
    };
    sharedFilesArr: Array<TSharedFile>;
    notificationSounds: TNotifSounds;
    chatNotif: boolean;
    peerJoinNotif: boolean;
    peerLeaveNotif: boolean;
    setchatNotif: (value: boolean) => void;
    setpeerJoinNotif: (value: boolean) => void;
    setpeerLeaveNotif: (value: boolean) => void;
    setNotificationSounds: (sounds: TNotifSounds) => void;
    setChat: (chat: IChatText, toId: string, err?: IChatErrorType) => void;
    removeChat: (toId: string) => void;
    increaseUnread: (chatRoomId: string) => void;
    removeUnread: (chatRoomId: string) => void;
    addSharedFile: (file: TSharedFile) => void;
    setSharedFiles: (sharedFiles: TSharedFile[]) => void;
}
interface ILobbyPeer {
    peerId: string;
    displayName: string;
    avatarUrl?: string;
}
interface ILobbyPeersStoreType {
    lobbyPeers: ILobbyPeer[];
    addLobbyPeer: (peer: ILobbyPeer) => void;
    setLobbyPeers: (peers: ILobbyPeer[]) => void;
}
declare type IDropReason = 'left' | 'timeout' | 'kicked' | 'unhandled' | 'not-joined' | 'denied' | 'closedByHost';
declare type IRoomState = {
    roomId: string;
    joined: boolean;
    droppedState: {
        type: IDropReason;
        isDropped: boolean;
    };
    createdAt: number;
    isRoomLocked: boolean;
};
interface IRoomStateStoreType {
    roomState: IRoomState;
    setRoomLockState: (isRoomLocked: boolean) => void;
    setRoomId: (roomId: string) => void;
    setJoined: () => void;
    setDropState: (dropReason: IDropReason) => void;
    setCreatedAt: (createdAt: number) => void;
}
interface IFigmentStoreType {
    isFigmentEnabled: boolean;
    figment: {
        figmentType: 'blur' | 'image' | 'video' | 'enable';
        figmentStream: MediaStream | null;
        figmentLoading: boolean;
        figmentstreamError: {
            type: IMediErrorType;
            blocked: boolean;
        } | null;
    };
    setFigmentEnabled: (isFigmentEnabled: boolean) => void;
    toggleFigmentType: (figmentType: 'blur' | 'image' | 'video') => void;
    setFigmentStream: (stream: MediaStream) => void;
    toggleFigmentStream: (streamState: 'enable' | 'disable' | 'switch') => Promise<void>;
    enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo) => Promise<void>;
    disableFigmentStream: () => void;
    setFigmentStreamError: (error: IMediErrorType) => void;
    initFigmentStream: () => Promise<void>;
}
declare type IEnableHostControl = {
    [key in EEnableHostControl]: () => void;
};
declare type IDisableHostControl = {
    [key in EDisableHostControl]: () => void;
};
declare type THostControls = {
    allowVideo: boolean;
    allowAudio: boolean;
    allowScreenShare: boolean;
    allowChat: boolean;
};
declare type IHostState = 'host-false' | 'host-true' | 'no-host';
interface IHostControlsStoreType {
    hostId: string | null;
    hostState: IHostState;
    meId: string;
    coHosts: string[];
    hostControl: THostControls;
    setHost: (hostId: string) => void;
    setCoHosts: (coHosts: string[]) => void;
    setHostState: (hostState: IHostState) => void;
    setHostControl: (control: THostControls) => void;
    setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
    initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[]) => void;
}
interface IActiveSpeakerState {
    dominantSpeaker: string;
    peerIdToVolume: Record<string, number>;
    addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
    removeStreamFromHark: (peerId: string) => void;
}
declare type IStreamingPlatform = 'youtube' | 'livepeer' | 'twitch';
declare type IStreamData = {
    url: string;
    isLive: boolean;
    isLoading: boolean;
};
interface ILiveStream {
    streamData: {
        [key in IStreamingPlatform]?: IStreamData;
    };
    isLiveStreaming: boolean;
    livePlatform: IStreamingPlatform;
    setPlatform: (platform: IStreamingPlatform) => void;
    startStreaming: (platform: IStreamingPlatform) => void;
    stopStreaming: (platform: IStreamingPlatform) => void;
    setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
    removeStreamData: (platform: IStreamingPlatform) => void;
}
declare type ILayoutSchemaType = 'gridView' | 'sideBarGridView' | 'sideBarView' | 'spotlightView';
interface ILayoutSlice {
    layout: {
        type: ILayoutSchemaType;
    };
    setLayoutView: (type: ILayoutSchemaType) => void;
}
interface IPeerNameSlice {
    peerDisplayName: string;
    setPeerDisplayName: (peerDisplayName: string | undefined) => void;
}
declare type IState = IGridState & ILiveStream & ITestState & IPeerStoreType & IMeStoreType & ILastNStoreType & IRecordingStoreType & IMediaSlice & IFigmentStoreType & IChatStoreType & ILobbyPeersStoreType & IRoomStateStoreType & IHostControlsStoreType & INetworkState & IHostControlsStoreType & IMicSlice & ISpeakerState & IActiveSpeakerState & IPeerNameSlice & ILayoutSlice;

export { GridViewTypes, IActiveSpeakerState, IChatErrorType, IChatMessage, IChatStoreType, IChatText, IChatType, IDeviceSwitch, IDisableHostControl, IDropReason, IEnableHostControl, IFigmentStoreType, IGridState, IHostControlsStoreType, IHostState, ILastNStoreType, ILayoutSchemaType, ILayoutSlice, ILiveStream, ILobbyPeer, ILobbyPeersStoreType, IMeInitState, IMeState, IMeStoreStateKeys, IMeStoreType, IMediErrorType, IMediaSlice, IMicSlice, INetworkState, INewPeerState, IPeerNameSlice, IPeerState, IPeerStoreState, IPeerStoreStateKeys, IPeerStoreType, IPeersState, IRecordingStoreType, IRecordingType, IRoomState, IRoomStateStoreType, ISpeakerState, IState, IStreamData, IStreamingPlatform, ITestState, MediaConsumer, MediaConsumerTracks, MediaConsumerTypes, MediaConsumerTypesEnum, MediaConsumerTypesObj, Reaction, StoreSlice, THostControls, TMediaDevice, TNetStats, TNotifSounds, TSharedFile };
