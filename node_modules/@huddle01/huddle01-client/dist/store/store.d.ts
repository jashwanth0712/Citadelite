import * as zustand from 'zustand';
import { GetState } from 'zustand';
import { ILayoutSchemaType, IStreamData, IStreamingPlatform, IHostState, THostControls, TNetStats, IRoomState, IDropReason, ILobbyPeer, IChatMessage, TSharedFile, TNotifSounds, IChatText, IChatErrorType, IRecordingType, INewPeerState, MediaConsumerTypes, MediaConsumer, Reaction, IPeerStoreState, IMeInitState, IMeStoreStateKeys, IDeviceSwitch, MediaConsumerTracks, GridViewTypes } from './storeTypes.js';
import '../schema/enums/EHostControlType.js';

declare const store: Omit<zustand.StoreApi<{
    peerDisplayName: string;
    setPeerDisplayName: (peerDisplayName: string | undefined) => void;
    layout: {
        type: ILayoutSchemaType;
    };
    setLayoutView: (type: ILayoutSchemaType) => void;
    dominantSpeaker: string;
    peerIdToVolume: Record<string, number>;
    addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
    removeStreamFromHark: (peerId: string) => void;
    micState: {
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
    };
    audioDevices: MediaDeviceInfo[];
    enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setAudioDevice: (device: MediaDeviceInfo) => void;
    getAudioDevices: () => Promise<MediaDeviceInfo[]>;
    setAudioStream: (stream: MediaStream | null) => void;
    pauseAudioTracks: () => void;
    switchAudioStream: (stream: MediaStream | null) => void;
    setAudioDeviceLoading: (loading: boolean) => void;
    setAudioStreamError: (error: string) => void;
    activeSpeaker: MediaDeviceInfo | null;
    setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
    streamData: {
        youtube?: IStreamData | undefined;
        livepeer?: IStreamData | undefined;
        twitch?: IStreamData | undefined;
    };
    isLiveStreaming: boolean;
    livePlatform: IStreamingPlatform;
    setPlatform: (platform: IStreamingPlatform) => void;
    startStreaming: (platform: IStreamingPlatform) => void;
    stopStreaming: (platform: IStreamingPlatform) => void;
    setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
    removeStreamData: (platform: IStreamingPlatform) => void;
    hostId: string | null;
    hostState: IHostState;
    meId: string;
    coHosts: string[];
    hostControl: THostControls;
    setHost: (hostId: string) => void;
    setCoHosts: (coHosts: string[]) => void;
    setHostState: (hostState: IHostState) => void;
    setHostControl: (control: THostControls) => void;
    setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
    initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
    networkStats: TNetStats;
    bandwidthSaver: boolean;
    setBandwidthSaver: (value: boolean) => void;
    setNetworkStats: (networkStats: TNetStats) => void;
    roomState: IRoomState;
    setRoomLockState: (isRoomLocked: boolean) => void;
    setRoomId: (roomId: string) => void;
    setJoined: () => void;
    setDropState: (dropReason: IDropReason) => void;
    setCreatedAt: (createdAt: number) => void;
    lobbyPeers: ILobbyPeer[];
    addLobbyPeer: (peer: ILobbyPeer) => void;
    setLobbyPeers: (peers: ILobbyPeer[]) => void;
    unread: {
        [chatRoomId: string]: number;
    };
    chat: {
        [chatRoomId: string]: IChatMessage[];
    };
    reactions: {
        [peerId: string]: string;
    };
    sharedFilesArr: TSharedFile[];
    notificationSounds: TNotifSounds;
    chatNotif: boolean;
    peerJoinNotif: boolean;
    peerLeaveNotif: boolean;
    setchatNotif: (value: boolean) => void;
    setpeerJoinNotif: (value: boolean) => void;
    setpeerLeaveNotif: (value: boolean) => void;
    setNotificationSounds: (sounds: TNotifSounds) => void;
    setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
    removeChat: (toId: string) => void;
    increaseUnread: (chatRoomId: string) => void;
    removeUnread: (chatRoomId: string) => void;
    addSharedFile: (file: TSharedFile) => void;
    setSharedFiles: (sharedFiles: TSharedFile[]) => void;
    recordingState: {
        inProgress: boolean;
        processing: boolean;
        started: boolean;
    };
    uploadToIpfs: boolean;
    recordings: IRecordingType[];
    newRecording: IRecordingType | null;
    notifyRecording: {
        started: boolean;
        finished: boolean;
    };
    startRecording: () => void;
    toggleRecording: (started: boolean) => void;
    stopRecording: () => void;
    updateRecordings: (recording: IRecordingType) => void;
    setRecordings: (recordings: IRecordingType[]) => void;
    removeNewrecording: () => void;
    endRecording: () => void;
    setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
    isFigmentEnabled: boolean;
    figment: {
        figmentType: "video" | "blur" | "image" | "enable";
        figmentStream: MediaStream | null;
        figmentLoading: boolean;
        figmentstreamError: {
            type: string;
            blocked: boolean;
        } | null;
    };
    setFigmentEnabled: (isFigmentEnabled: boolean) => void;
    toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
    setFigmentStream: (stream: MediaStream) => void;
    toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
    enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
    disableFigmentStream: () => void;
    setFigmentStreamError: (error: string) => void;
    initFigmentStream: () => Promise<void>;
    mediaDevice: MediaDeviceInfo | null;
    stream: MediaStream | null;
    streamError: {
        type: string;
        blocked: boolean;
    } | null;
    deviceLoading: boolean;
    streamsArry: MediaStream[];
    enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setMediaDevice: (device: MediaDeviceInfo) => void;
    getMediaDevices: () => Promise<MediaDeviceInfo[]>;
    setMediaStream: (stream: MediaStream | null) => void;
    pauseTracks: () => void;
    switchMediaStream: (stream: MediaStream | null) => void;
    setDeviceLoading: (loading: boolean) => void;
    setStreamError: (error: string) => void;
    maxViewPortCount: number;
    activeViewPort: number;
    isLastNActive: boolean;
    lastNPeerIds: string[];
    getTotalNumberOfSwaps: (newLastN: string[]) => number;
    setLastNPeerIds: (lastNPeerIds: string[]) => void;
    addPeerToLastN: (peerId: string) => void;
    removePeerFromLastN: (peerId: string) => void;
    activateLastN: () => void;
    deactivateLastN: () => void;
    addActiveViewPort: (value?: number | undefined) => void;
    removeActiveViewPort: (value?: number | undefined) => void;
    isTest: boolean;
    toggleIsTest: () => void;
    peerCount: number;
    increasePeerCount: (value: number) => void;
    decreasePeerCount: (value: number) => void;
    addPeer: (peerId: string, peer: INewPeerState) => void;
    removePeer: (peerId: string) => void;
    addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
    pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
    addReaction: (peerId: string, reaction: Reaction) => void;
    removeReaction: (peerId: string) => void;
    setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
    peers: {
        [peerId: string]: IPeerStoreState;
    };
    geo: string;
    initMe: (meInit: IMeInitState) => void;
    setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
    setGeo: (geo: string) => void;
    setAvatarUrl: (avatar: string) => void;
    addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
    removeProducerMedia: (producerType: MediaConsumerTypes) => void;
    updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
    toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
    toggleMeHandRaise: (isHandRaised: boolean) => void;
    addMeReaction: (reaction: Reaction) => void;
    rmMeReaction: () => void;
    peerId: string;
    displayName: string;
    avatarUrl: string;
    producers: MediaConsumerTracks;
    isMicPaused: boolean;
    isCamPaused: boolean;
    isSharePaused: boolean;
    isHandRaised: boolean;
    reaction: Reaction;
    gridView: GridViewTypes;
    screenSharePeerId?: string | null | undefined;
    setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
    enableScreenShare: (peerId: string) => void;
    disableScreenShare: (gridView: GridViewTypes) => void;
}>, "setState"> & {
    setState(partial: {
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    } | Partial<{
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    }> | ((state: {
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    }) => {
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    } | Partial<{
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    }>), replace?: boolean | undefined, actionType?: string | {
        type: unknown;
    } | undefined): void;
};
declare const useRootStore: zustand.UseBoundStore<Omit<zustand.StoreApi<{
    peerDisplayName: string;
    setPeerDisplayName: (peerDisplayName: string | undefined) => void;
    layout: {
        type: ILayoutSchemaType;
    };
    setLayoutView: (type: ILayoutSchemaType) => void;
    dominantSpeaker: string;
    peerIdToVolume: Record<string, number>;
    addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
    removeStreamFromHark: (peerId: string) => void;
    micState: {
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
    };
    audioDevices: MediaDeviceInfo[];
    enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setAudioDevice: (device: MediaDeviceInfo) => void;
    getAudioDevices: () => Promise<MediaDeviceInfo[]>;
    setAudioStream: (stream: MediaStream | null) => void;
    pauseAudioTracks: () => void;
    switchAudioStream: (stream: MediaStream | null) => void;
    setAudioDeviceLoading: (loading: boolean) => void;
    setAudioStreamError: (error: string) => void;
    activeSpeaker: MediaDeviceInfo | null;
    setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
    streamData: {
        youtube?: IStreamData | undefined;
        livepeer?: IStreamData | undefined;
        twitch?: IStreamData | undefined;
    };
    isLiveStreaming: boolean;
    livePlatform: IStreamingPlatform;
    setPlatform: (platform: IStreamingPlatform) => void;
    startStreaming: (platform: IStreamingPlatform) => void;
    stopStreaming: (platform: IStreamingPlatform) => void;
    setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
    removeStreamData: (platform: IStreamingPlatform) => void;
    hostId: string | null;
    hostState: IHostState;
    meId: string;
    coHosts: string[];
    hostControl: THostControls;
    setHost: (hostId: string) => void;
    setCoHosts: (coHosts: string[]) => void;
    setHostState: (hostState: IHostState) => void;
    setHostControl: (control: THostControls) => void;
    setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
    initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
    networkStats: TNetStats;
    bandwidthSaver: boolean;
    setBandwidthSaver: (value: boolean) => void;
    setNetworkStats: (networkStats: TNetStats) => void;
    roomState: IRoomState;
    setRoomLockState: (isRoomLocked: boolean) => void;
    setRoomId: (roomId: string) => void;
    setJoined: () => void;
    setDropState: (dropReason: IDropReason) => void;
    setCreatedAt: (createdAt: number) => void;
    lobbyPeers: ILobbyPeer[];
    addLobbyPeer: (peer: ILobbyPeer) => void;
    setLobbyPeers: (peers: ILobbyPeer[]) => void;
    unread: {
        [chatRoomId: string]: number;
    };
    chat: {
        [chatRoomId: string]: IChatMessage[];
    };
    reactions: {
        [peerId: string]: string;
    };
    sharedFilesArr: TSharedFile[];
    notificationSounds: TNotifSounds;
    chatNotif: boolean;
    peerJoinNotif: boolean;
    peerLeaveNotif: boolean;
    setchatNotif: (value: boolean) => void;
    setpeerJoinNotif: (value: boolean) => void;
    setpeerLeaveNotif: (value: boolean) => void;
    setNotificationSounds: (sounds: TNotifSounds) => void;
    setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
    removeChat: (toId: string) => void;
    increaseUnread: (chatRoomId: string) => void;
    removeUnread: (chatRoomId: string) => void;
    addSharedFile: (file: TSharedFile) => void;
    setSharedFiles: (sharedFiles: TSharedFile[]) => void;
    recordingState: {
        inProgress: boolean;
        processing: boolean;
        started: boolean;
    };
    uploadToIpfs: boolean;
    recordings: IRecordingType[];
    newRecording: IRecordingType | null;
    notifyRecording: {
        started: boolean;
        finished: boolean;
    };
    startRecording: () => void;
    toggleRecording: (started: boolean) => void;
    stopRecording: () => void;
    updateRecordings: (recording: IRecordingType) => void;
    setRecordings: (recordings: IRecordingType[]) => void;
    removeNewrecording: () => void;
    endRecording: () => void;
    setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
    isFigmentEnabled: boolean;
    figment: {
        figmentType: "video" | "blur" | "image" | "enable";
        figmentStream: MediaStream | null;
        figmentLoading: boolean;
        figmentstreamError: {
            type: string;
            blocked: boolean;
        } | null;
    };
    setFigmentEnabled: (isFigmentEnabled: boolean) => void;
    toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
    setFigmentStream: (stream: MediaStream) => void;
    toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
    enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
    disableFigmentStream: () => void;
    setFigmentStreamError: (error: string) => void;
    initFigmentStream: () => Promise<void>;
    mediaDevice: MediaDeviceInfo | null;
    stream: MediaStream | null;
    streamError: {
        type: string;
        blocked: boolean;
    } | null;
    deviceLoading: boolean;
    streamsArry: MediaStream[];
    enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setMediaDevice: (device: MediaDeviceInfo) => void;
    getMediaDevices: () => Promise<MediaDeviceInfo[]>;
    setMediaStream: (stream: MediaStream | null) => void;
    pauseTracks: () => void;
    switchMediaStream: (stream: MediaStream | null) => void;
    setDeviceLoading: (loading: boolean) => void;
    setStreamError: (error: string) => void;
    maxViewPortCount: number;
    activeViewPort: number;
    isLastNActive: boolean;
    lastNPeerIds: string[];
    getTotalNumberOfSwaps: (newLastN: string[]) => number;
    setLastNPeerIds: (lastNPeerIds: string[]) => void;
    addPeerToLastN: (peerId: string) => void;
    removePeerFromLastN: (peerId: string) => void;
    activateLastN: () => void;
    deactivateLastN: () => void;
    addActiveViewPort: (value?: number | undefined) => void;
    removeActiveViewPort: (value?: number | undefined) => void;
    isTest: boolean;
    toggleIsTest: () => void;
    peerCount: number;
    increasePeerCount: (value: number) => void;
    decreasePeerCount: (value: number) => void;
    addPeer: (peerId: string, peer: INewPeerState) => void;
    removePeer: (peerId: string) => void;
    addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
    pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
    addReaction: (peerId: string, reaction: Reaction) => void;
    removeReaction: (peerId: string) => void;
    setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
    peers: {
        [peerId: string]: IPeerStoreState;
    };
    geo: string;
    initMe: (meInit: IMeInitState) => void;
    setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
    setGeo: (geo: string) => void;
    setAvatarUrl: (avatar: string) => void;
    addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
    removeProducerMedia: (producerType: MediaConsumerTypes) => void;
    updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
    toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
    toggleMeHandRaise: (isHandRaised: boolean) => void;
    addMeReaction: (reaction: Reaction) => void;
    rmMeReaction: () => void;
    peerId: string;
    displayName: string;
    avatarUrl: string;
    producers: MediaConsumerTracks;
    isMicPaused: boolean;
    isCamPaused: boolean;
    isSharePaused: boolean;
    isHandRaised: boolean;
    reaction: Reaction;
    gridView: GridViewTypes;
    screenSharePeerId?: string | null | undefined;
    setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
    enableScreenShare: (peerId: string) => void;
    disableScreenShare: (gridView: GridViewTypes) => void;
}>, "setState"> & {
    setState(partial: {
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    } | Partial<{
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    }> | ((state: {
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    }) => {
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    } | Partial<{
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    }>), replace?: boolean | undefined, actionType?: string | {
        type: unknown;
    } | undefined): void;
}>;
declare const useHuddleStore: zustand.UseBoundStore<Omit<zustand.StoreApi<{
    peerDisplayName: string;
    setPeerDisplayName: (peerDisplayName: string | undefined) => void;
    layout: {
        type: ILayoutSchemaType;
    };
    setLayoutView: (type: ILayoutSchemaType) => void;
    dominantSpeaker: string;
    peerIdToVolume: Record<string, number>;
    addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
    removeStreamFromHark: (peerId: string) => void;
    micState: {
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
    };
    audioDevices: MediaDeviceInfo[];
    enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setAudioDevice: (device: MediaDeviceInfo) => void;
    getAudioDevices: () => Promise<MediaDeviceInfo[]>;
    setAudioStream: (stream: MediaStream | null) => void;
    pauseAudioTracks: () => void;
    switchAudioStream: (stream: MediaStream | null) => void;
    setAudioDeviceLoading: (loading: boolean) => void;
    setAudioStreamError: (error: string) => void;
    activeSpeaker: MediaDeviceInfo | null;
    setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
    streamData: {
        youtube?: IStreamData | undefined;
        livepeer?: IStreamData | undefined;
        twitch?: IStreamData | undefined;
    };
    isLiveStreaming: boolean;
    livePlatform: IStreamingPlatform;
    setPlatform: (platform: IStreamingPlatform) => void;
    startStreaming: (platform: IStreamingPlatform) => void;
    stopStreaming: (platform: IStreamingPlatform) => void;
    setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
    removeStreamData: (platform: IStreamingPlatform) => void;
    hostId: string | null;
    hostState: IHostState;
    meId: string;
    coHosts: string[];
    hostControl: THostControls;
    setHost: (hostId: string) => void;
    setCoHosts: (coHosts: string[]) => void;
    setHostState: (hostState: IHostState) => void;
    setHostControl: (control: THostControls) => void;
    setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
    initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
    networkStats: TNetStats;
    bandwidthSaver: boolean;
    setBandwidthSaver: (value: boolean) => void;
    setNetworkStats: (networkStats: TNetStats) => void;
    roomState: IRoomState;
    setRoomLockState: (isRoomLocked: boolean) => void;
    setRoomId: (roomId: string) => void;
    setJoined: () => void;
    setDropState: (dropReason: IDropReason) => void;
    setCreatedAt: (createdAt: number) => void;
    lobbyPeers: ILobbyPeer[];
    addLobbyPeer: (peer: ILobbyPeer) => void;
    setLobbyPeers: (peers: ILobbyPeer[]) => void;
    unread: {
        [chatRoomId: string]: number;
    };
    chat: {
        [chatRoomId: string]: IChatMessage[];
    };
    reactions: {
        [peerId: string]: string;
    };
    sharedFilesArr: TSharedFile[];
    notificationSounds: TNotifSounds;
    chatNotif: boolean;
    peerJoinNotif: boolean;
    peerLeaveNotif: boolean;
    setchatNotif: (value: boolean) => void;
    setpeerJoinNotif: (value: boolean) => void;
    setpeerLeaveNotif: (value: boolean) => void;
    setNotificationSounds: (sounds: TNotifSounds) => void;
    setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
    removeChat: (toId: string) => void;
    increaseUnread: (chatRoomId: string) => void;
    removeUnread: (chatRoomId: string) => void;
    addSharedFile: (file: TSharedFile) => void;
    setSharedFiles: (sharedFiles: TSharedFile[]) => void;
    recordingState: {
        inProgress: boolean;
        processing: boolean;
        started: boolean;
    };
    uploadToIpfs: boolean;
    recordings: IRecordingType[];
    newRecording: IRecordingType | null;
    notifyRecording: {
        started: boolean;
        finished: boolean;
    };
    startRecording: () => void;
    toggleRecording: (started: boolean) => void;
    stopRecording: () => void;
    updateRecordings: (recording: IRecordingType) => void;
    setRecordings: (recordings: IRecordingType[]) => void;
    removeNewrecording: () => void;
    endRecording: () => void;
    setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
    isFigmentEnabled: boolean;
    figment: {
        figmentType: "video" | "blur" | "image" | "enable";
        figmentStream: MediaStream | null;
        figmentLoading: boolean;
        figmentstreamError: {
            type: string;
            blocked: boolean;
        } | null;
    };
    setFigmentEnabled: (isFigmentEnabled: boolean) => void;
    toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
    setFigmentStream: (stream: MediaStream) => void;
    toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
    enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
    disableFigmentStream: () => void;
    setFigmentStreamError: (error: string) => void;
    initFigmentStream: () => Promise<void>;
    mediaDevice: MediaDeviceInfo | null;
    stream: MediaStream | null;
    streamError: {
        type: string;
        blocked: boolean;
    } | null;
    deviceLoading: boolean;
    streamsArry: MediaStream[];
    enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setMediaDevice: (device: MediaDeviceInfo) => void;
    getMediaDevices: () => Promise<MediaDeviceInfo[]>;
    setMediaStream: (stream: MediaStream | null) => void;
    pauseTracks: () => void;
    switchMediaStream: (stream: MediaStream | null) => void;
    setDeviceLoading: (loading: boolean) => void;
    setStreamError: (error: string) => void;
    maxViewPortCount: number;
    activeViewPort: number;
    isLastNActive: boolean;
    lastNPeerIds: string[];
    getTotalNumberOfSwaps: (newLastN: string[]) => number;
    setLastNPeerIds: (lastNPeerIds: string[]) => void;
    addPeerToLastN: (peerId: string) => void;
    removePeerFromLastN: (peerId: string) => void;
    activateLastN: () => void;
    deactivateLastN: () => void;
    addActiveViewPort: (value?: number | undefined) => void;
    removeActiveViewPort: (value?: number | undefined) => void;
    isTest: boolean;
    toggleIsTest: () => void;
    peerCount: number;
    increasePeerCount: (value: number) => void;
    decreasePeerCount: (value: number) => void;
    addPeer: (peerId: string, peer: INewPeerState) => void;
    removePeer: (peerId: string) => void;
    addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
    pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
    addReaction: (peerId: string, reaction: Reaction) => void;
    removeReaction: (peerId: string) => void;
    setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
    peers: {
        [peerId: string]: IPeerStoreState;
    };
    geo: string;
    initMe: (meInit: IMeInitState) => void;
    setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
    setGeo: (geo: string) => void;
    setAvatarUrl: (avatar: string) => void;
    addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
    removeProducerMedia: (producerType: MediaConsumerTypes) => void;
    updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
    toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
    toggleMeHandRaise: (isHandRaised: boolean) => void;
    addMeReaction: (reaction: Reaction) => void;
    rmMeReaction: () => void;
    peerId: string;
    displayName: string;
    avatarUrl: string;
    producers: MediaConsumerTracks;
    isMicPaused: boolean;
    isCamPaused: boolean;
    isSharePaused: boolean;
    isHandRaised: boolean;
    reaction: Reaction;
    gridView: GridViewTypes;
    screenSharePeerId?: string | null | undefined;
    setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
    enableScreenShare: (peerId: string) => void;
    disableScreenShare: (gridView: GridViewTypes) => void;
}>, "setState"> & {
    setState(partial: {
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    } | Partial<{
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    }> | ((state: {
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    }) => {
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    } | Partial<{
        peerDisplayName: string;
        setPeerDisplayName: (peerDisplayName: string | undefined) => void;
        layout: {
            type: ILayoutSchemaType;
        };
        setLayoutView: (type: ILayoutSchemaType) => void;
        dominantSpeaker: string;
        peerIdToVolume: Record<string, number>;
        addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
        removeStreamFromHark: (peerId: string) => void;
        micState: {
            mediaDevice: MediaDeviceInfo | null;
            stream: MediaStream | null;
            streamError: {
                type: string;
                blocked: boolean;
            } | null;
            deviceLoading: boolean;
        };
        audioDevices: MediaDeviceInfo[];
        enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setAudioDevice: (device: MediaDeviceInfo) => void;
        getAudioDevices: () => Promise<MediaDeviceInfo[]>;
        setAudioStream: (stream: MediaStream | null) => void;
        pauseAudioTracks: () => void;
        switchAudioStream: (stream: MediaStream | null) => void;
        setAudioDeviceLoading: (loading: boolean) => void;
        setAudioStreamError: (error: string) => void;
        activeSpeaker: MediaDeviceInfo | null;
        setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
        streamData: {
            youtube?: IStreamData | undefined;
            livepeer?: IStreamData | undefined;
            twitch?: IStreamData | undefined;
        };
        isLiveStreaming: boolean;
        livePlatform: IStreamingPlatform;
        setPlatform: (platform: IStreamingPlatform) => void;
        startStreaming: (platform: IStreamingPlatform) => void;
        stopStreaming: (platform: IStreamingPlatform) => void;
        setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
        removeStreamData: (platform: IStreamingPlatform) => void;
        hostId: string | null;
        hostState: IHostState;
        meId: string;
        coHosts: string[];
        hostControl: THostControls;
        setHost: (hostId: string) => void;
        setCoHosts: (coHosts: string[]) => void;
        setHostState: (hostState: IHostState) => void;
        setHostControl: (control: THostControls) => void;
        setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
        initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
        networkStats: TNetStats;
        bandwidthSaver: boolean;
        setBandwidthSaver: (value: boolean) => void;
        setNetworkStats: (networkStats: TNetStats) => void;
        roomState: IRoomState;
        setRoomLockState: (isRoomLocked: boolean) => void;
        setRoomId: (roomId: string) => void;
        setJoined: () => void;
        setDropState: (dropReason: IDropReason) => void;
        setCreatedAt: (createdAt: number) => void;
        lobbyPeers: ILobbyPeer[];
        addLobbyPeer: (peer: ILobbyPeer) => void;
        setLobbyPeers: (peers: ILobbyPeer[]) => void;
        unread: {
            [chatRoomId: string]: number;
        };
        chat: {
            [chatRoomId: string]: IChatMessage[];
        };
        reactions: {
            [peerId: string]: string;
        };
        sharedFilesArr: TSharedFile[];
        notificationSounds: TNotifSounds;
        chatNotif: boolean;
        peerJoinNotif: boolean;
        peerLeaveNotif: boolean;
        setchatNotif: (value: boolean) => void;
        setpeerJoinNotif: (value: boolean) => void;
        setpeerLeaveNotif: (value: boolean) => void;
        setNotificationSounds: (sounds: TNotifSounds) => void;
        setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
        removeChat: (toId: string) => void;
        increaseUnread: (chatRoomId: string) => void;
        removeUnread: (chatRoomId: string) => void;
        addSharedFile: (file: TSharedFile) => void;
        setSharedFiles: (sharedFiles: TSharedFile[]) => void;
        recordingState: {
            inProgress: boolean;
            processing: boolean;
            started: boolean;
        };
        uploadToIpfs: boolean;
        recordings: IRecordingType[];
        newRecording: IRecordingType | null;
        notifyRecording: {
            started: boolean;
            finished: boolean;
        };
        startRecording: () => void;
        toggleRecording: (started: boolean) => void;
        stopRecording: () => void;
        updateRecordings: (recording: IRecordingType) => void;
        setRecordings: (recordings: IRecordingType[]) => void;
        removeNewrecording: () => void;
        endRecording: () => void;
        setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
        isFigmentEnabled: boolean;
        figment: {
            figmentType: "video" | "blur" | "image" | "enable";
            figmentStream: MediaStream | null;
            figmentLoading: boolean;
            figmentstreamError: {
                type: string;
                blocked: boolean;
            } | null;
        };
        setFigmentEnabled: (isFigmentEnabled: boolean) => void;
        toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
        setFigmentStream: (stream: MediaStream) => void;
        toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
        enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
        disableFigmentStream: () => void;
        setFigmentStreamError: (error: string) => void;
        initFigmentStream: () => Promise<void>;
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
        streamsArry: MediaStream[];
        enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
        setMediaDevice: (device: MediaDeviceInfo) => void;
        getMediaDevices: () => Promise<MediaDeviceInfo[]>;
        setMediaStream: (stream: MediaStream | null) => void;
        pauseTracks: () => void;
        switchMediaStream: (stream: MediaStream | null) => void;
        setDeviceLoading: (loading: boolean) => void;
        setStreamError: (error: string) => void;
        maxViewPortCount: number;
        activeViewPort: number;
        isLastNActive: boolean;
        lastNPeerIds: string[];
        getTotalNumberOfSwaps: (newLastN: string[]) => number;
        setLastNPeerIds: (lastNPeerIds: string[]) => void;
        addPeerToLastN: (peerId: string) => void;
        removePeerFromLastN: (peerId: string) => void;
        activateLastN: () => void;
        deactivateLastN: () => void;
        addActiveViewPort: (value?: number | undefined) => void;
        removeActiveViewPort: (value?: number | undefined) => void;
        isTest: boolean;
        toggleIsTest: () => void;
        peerCount: number;
        increasePeerCount: (value: number) => void;
        decreasePeerCount: (value: number) => void;
        addPeer: (peerId: string, peer: INewPeerState) => void;
        removePeer: (peerId: string) => void;
        addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
        pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
        togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
        addReaction: (peerId: string, reaction: Reaction) => void;
        removeReaction: (peerId: string) => void;
        setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
        peers: {
            [peerId: string]: IPeerStoreState;
        };
        geo: string;
        initMe: (meInit: IMeInitState) => void;
        setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
        setGeo: (geo: string) => void;
        setAvatarUrl: (avatar: string) => void;
        addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
        removeProducerMedia: (producerType: MediaConsumerTypes) => void;
        updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
        toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
        toggleMeHandRaise: (isHandRaised: boolean) => void;
        addMeReaction: (reaction: Reaction) => void;
        rmMeReaction: () => void;
        peerId: string;
        displayName: string;
        avatarUrl: string;
        producers: MediaConsumerTracks;
        isMicPaused: boolean;
        isCamPaused: boolean;
        isSharePaused: boolean;
        isHandRaised: boolean;
        reaction: Reaction;
        gridView: GridViewTypes;
        screenSharePeerId?: string | null | undefined;
        setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
        enableScreenShare: (peerId: string) => void;
        disableScreenShare: (gridView: GridViewTypes) => void;
    }>), replace?: boolean | undefined, actionType?: string | {
        type: unknown;
    } | undefined): void;
}>;
declare const getState: GetState<{
    peerDisplayName: string;
    setPeerDisplayName: (peerDisplayName: string | undefined) => void;
    layout: {
        type: ILayoutSchemaType;
    };
    setLayoutView: (type: ILayoutSchemaType) => void;
    dominantSpeaker: string;
    peerIdToVolume: Record<string, number>;
    addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
    removeStreamFromHark: (peerId: string) => void;
    micState: {
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
    };
    audioDevices: MediaDeviceInfo[];
    enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setAudioDevice: (device: MediaDeviceInfo) => void;
    getAudioDevices: () => Promise<MediaDeviceInfo[]>;
    setAudioStream: (stream: MediaStream | null) => void;
    pauseAudioTracks: () => void;
    switchAudioStream: (stream: MediaStream | null) => void;
    setAudioDeviceLoading: (loading: boolean) => void;
    setAudioStreamError: (error: string) => void;
    activeSpeaker: MediaDeviceInfo | null;
    setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
    streamData: {
        youtube?: IStreamData | undefined;
        livepeer?: IStreamData | undefined;
        twitch?: IStreamData | undefined;
    };
    isLiveStreaming: boolean;
    livePlatform: IStreamingPlatform;
    setPlatform: (platform: IStreamingPlatform) => void;
    startStreaming: (platform: IStreamingPlatform) => void;
    stopStreaming: (platform: IStreamingPlatform) => void;
    setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
    removeStreamData: (platform: IStreamingPlatform) => void;
    hostId: string | null;
    hostState: IHostState;
    meId: string;
    coHosts: string[];
    hostControl: THostControls;
    setHost: (hostId: string) => void;
    setCoHosts: (coHosts: string[]) => void;
    setHostState: (hostState: IHostState) => void;
    setHostControl: (control: THostControls) => void;
    setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
    initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
    networkStats: TNetStats;
    bandwidthSaver: boolean;
    setBandwidthSaver: (value: boolean) => void;
    setNetworkStats: (networkStats: TNetStats) => void;
    roomState: IRoomState;
    setRoomLockState: (isRoomLocked: boolean) => void;
    setRoomId: (roomId: string) => void;
    setJoined: () => void;
    setDropState: (dropReason: IDropReason) => void;
    setCreatedAt: (createdAt: number) => void;
    lobbyPeers: ILobbyPeer[];
    addLobbyPeer: (peer: ILobbyPeer) => void;
    setLobbyPeers: (peers: ILobbyPeer[]) => void;
    unread: {
        [chatRoomId: string]: number;
    };
    chat: {
        [chatRoomId: string]: IChatMessage[];
    };
    reactions: {
        [peerId: string]: string;
    };
    sharedFilesArr: TSharedFile[];
    notificationSounds: TNotifSounds;
    chatNotif: boolean;
    peerJoinNotif: boolean;
    peerLeaveNotif: boolean;
    setchatNotif: (value: boolean) => void;
    setpeerJoinNotif: (value: boolean) => void;
    setpeerLeaveNotif: (value: boolean) => void;
    setNotificationSounds: (sounds: TNotifSounds) => void;
    setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
    removeChat: (toId: string) => void;
    increaseUnread: (chatRoomId: string) => void;
    removeUnread: (chatRoomId: string) => void;
    addSharedFile: (file: TSharedFile) => void;
    setSharedFiles: (sharedFiles: TSharedFile[]) => void;
    recordingState: {
        inProgress: boolean;
        processing: boolean;
        started: boolean;
    };
    uploadToIpfs: boolean;
    recordings: IRecordingType[];
    newRecording: IRecordingType | null;
    notifyRecording: {
        started: boolean;
        finished: boolean;
    };
    startRecording: () => void;
    toggleRecording: (started: boolean) => void;
    stopRecording: () => void;
    updateRecordings: (recording: IRecordingType) => void;
    setRecordings: (recordings: IRecordingType[]) => void;
    removeNewrecording: () => void;
    endRecording: () => void;
    setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
    isFigmentEnabled: boolean;
    figment: {
        figmentType: "video" | "blur" | "image" | "enable";
        figmentStream: MediaStream | null;
        figmentLoading: boolean;
        figmentstreamError: {
            type: string;
            blocked: boolean;
        } | null;
    };
    setFigmentEnabled: (isFigmentEnabled: boolean) => void;
    toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
    setFigmentStream: (stream: MediaStream) => void;
    toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
    enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
    disableFigmentStream: () => void;
    setFigmentStreamError: (error: string) => void;
    initFigmentStream: () => Promise<void>;
    mediaDevice: MediaDeviceInfo | null;
    stream: MediaStream | null;
    streamError: {
        type: string;
        blocked: boolean;
    } | null;
    deviceLoading: boolean;
    streamsArry: MediaStream[];
    enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setMediaDevice: (device: MediaDeviceInfo) => void;
    getMediaDevices: () => Promise<MediaDeviceInfo[]>;
    setMediaStream: (stream: MediaStream | null) => void;
    pauseTracks: () => void;
    switchMediaStream: (stream: MediaStream | null) => void;
    setDeviceLoading: (loading: boolean) => void;
    setStreamError: (error: string) => void;
    maxViewPortCount: number;
    activeViewPort: number;
    isLastNActive: boolean;
    lastNPeerIds: string[];
    getTotalNumberOfSwaps: (newLastN: string[]) => number;
    setLastNPeerIds: (lastNPeerIds: string[]) => void;
    addPeerToLastN: (peerId: string) => void;
    removePeerFromLastN: (peerId: string) => void;
    activateLastN: () => void;
    deactivateLastN: () => void;
    addActiveViewPort: (value?: number | undefined) => void;
    removeActiveViewPort: (value?: number | undefined) => void;
    isTest: boolean;
    toggleIsTest: () => void;
    peerCount: number;
    increasePeerCount: (value: number) => void;
    decreasePeerCount: (value: number) => void;
    addPeer: (peerId: string, peer: INewPeerState) => void;
    removePeer: (peerId: string) => void;
    addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
    pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
    addReaction: (peerId: string, reaction: Reaction) => void;
    removeReaction: (peerId: string) => void;
    setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
    peers: {
        [peerId: string]: IPeerStoreState;
    };
    geo: string;
    initMe: (meInit: IMeInitState) => void;
    setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
    setGeo: (geo: string) => void;
    setAvatarUrl: (avatar: string) => void;
    addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
    removeProducerMedia: (producerType: MediaConsumerTypes) => void;
    updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
    toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
    toggleMeHandRaise: (isHandRaised: boolean) => void;
    addMeReaction: (reaction: Reaction) => void;
    rmMeReaction: () => void;
    peerId: string;
    displayName: string;
    avatarUrl: string;
    producers: MediaConsumerTracks;
    isMicPaused: boolean;
    isCamPaused: boolean;
    isSharePaused: boolean;
    isHandRaised: boolean;
    reaction: Reaction;
    gridView: GridViewTypes;
    screenSharePeerId?: string | null | undefined;
    setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
    enableScreenShare: (peerId: string) => void;
    disableScreenShare: (gridView: GridViewTypes) => void;
}>;
declare const setState: (partial: {
    peerDisplayName: string;
    setPeerDisplayName: (peerDisplayName: string | undefined) => void;
    layout: {
        type: ILayoutSchemaType;
    };
    setLayoutView: (type: ILayoutSchemaType) => void;
    dominantSpeaker: string;
    peerIdToVolume: Record<string, number>;
    addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
    removeStreamFromHark: (peerId: string) => void;
    micState: {
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
    };
    audioDevices: MediaDeviceInfo[];
    enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setAudioDevice: (device: MediaDeviceInfo) => void;
    getAudioDevices: () => Promise<MediaDeviceInfo[]>;
    setAudioStream: (stream: MediaStream | null) => void;
    pauseAudioTracks: () => void;
    switchAudioStream: (stream: MediaStream | null) => void;
    setAudioDeviceLoading: (loading: boolean) => void;
    setAudioStreamError: (error: string) => void;
    activeSpeaker: MediaDeviceInfo | null;
    setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
    streamData: {
        youtube?: IStreamData | undefined;
        livepeer?: IStreamData | undefined;
        twitch?: IStreamData | undefined;
    };
    isLiveStreaming: boolean;
    livePlatform: IStreamingPlatform;
    setPlatform: (platform: IStreamingPlatform) => void;
    startStreaming: (platform: IStreamingPlatform) => void;
    stopStreaming: (platform: IStreamingPlatform) => void;
    setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
    removeStreamData: (platform: IStreamingPlatform) => void;
    hostId: string | null;
    hostState: IHostState;
    meId: string;
    coHosts: string[];
    hostControl: THostControls;
    setHost: (hostId: string) => void;
    setCoHosts: (coHosts: string[]) => void;
    setHostState: (hostState: IHostState) => void;
    setHostControl: (control: THostControls) => void;
    setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
    initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
    networkStats: TNetStats;
    bandwidthSaver: boolean;
    setBandwidthSaver: (value: boolean) => void;
    setNetworkStats: (networkStats: TNetStats) => void;
    roomState: IRoomState;
    setRoomLockState: (isRoomLocked: boolean) => void;
    setRoomId: (roomId: string) => void;
    setJoined: () => void;
    setDropState: (dropReason: IDropReason) => void;
    setCreatedAt: (createdAt: number) => void;
    lobbyPeers: ILobbyPeer[];
    addLobbyPeer: (peer: ILobbyPeer) => void;
    setLobbyPeers: (peers: ILobbyPeer[]) => void;
    unread: {
        [chatRoomId: string]: number;
    };
    chat: {
        [chatRoomId: string]: IChatMessage[];
    };
    reactions: {
        [peerId: string]: string;
    };
    sharedFilesArr: TSharedFile[];
    notificationSounds: TNotifSounds;
    chatNotif: boolean;
    peerJoinNotif: boolean;
    peerLeaveNotif: boolean;
    setchatNotif: (value: boolean) => void;
    setpeerJoinNotif: (value: boolean) => void;
    setpeerLeaveNotif: (value: boolean) => void;
    setNotificationSounds: (sounds: TNotifSounds) => void;
    setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
    removeChat: (toId: string) => void;
    increaseUnread: (chatRoomId: string) => void;
    removeUnread: (chatRoomId: string) => void;
    addSharedFile: (file: TSharedFile) => void;
    setSharedFiles: (sharedFiles: TSharedFile[]) => void;
    recordingState: {
        inProgress: boolean;
        processing: boolean;
        started: boolean;
    };
    uploadToIpfs: boolean;
    recordings: IRecordingType[];
    newRecording: IRecordingType | null;
    notifyRecording: {
        started: boolean;
        finished: boolean;
    };
    startRecording: () => void;
    toggleRecording: (started: boolean) => void;
    stopRecording: () => void;
    updateRecordings: (recording: IRecordingType) => void;
    setRecordings: (recordings: IRecordingType[]) => void;
    removeNewrecording: () => void;
    endRecording: () => void;
    setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
    isFigmentEnabled: boolean;
    figment: {
        figmentType: "video" | "blur" | "image" | "enable";
        figmentStream: MediaStream | null;
        figmentLoading: boolean;
        figmentstreamError: {
            type: string;
            blocked: boolean;
        } | null;
    };
    setFigmentEnabled: (isFigmentEnabled: boolean) => void;
    toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
    setFigmentStream: (stream: MediaStream) => void;
    toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
    enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
    disableFigmentStream: () => void;
    setFigmentStreamError: (error: string) => void;
    initFigmentStream: () => Promise<void>;
    mediaDevice: MediaDeviceInfo | null;
    stream: MediaStream | null;
    streamError: {
        type: string;
        blocked: boolean;
    } | null;
    deviceLoading: boolean;
    streamsArry: MediaStream[];
    enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setMediaDevice: (device: MediaDeviceInfo) => void;
    getMediaDevices: () => Promise<MediaDeviceInfo[]>;
    setMediaStream: (stream: MediaStream | null) => void;
    pauseTracks: () => void;
    switchMediaStream: (stream: MediaStream | null) => void;
    setDeviceLoading: (loading: boolean) => void;
    setStreamError: (error: string) => void;
    maxViewPortCount: number;
    activeViewPort: number;
    isLastNActive: boolean;
    lastNPeerIds: string[];
    getTotalNumberOfSwaps: (newLastN: string[]) => number;
    setLastNPeerIds: (lastNPeerIds: string[]) => void;
    addPeerToLastN: (peerId: string) => void;
    removePeerFromLastN: (peerId: string) => void;
    activateLastN: () => void;
    deactivateLastN: () => void;
    addActiveViewPort: (value?: number | undefined) => void;
    removeActiveViewPort: (value?: number | undefined) => void;
    isTest: boolean;
    toggleIsTest: () => void;
    peerCount: number;
    increasePeerCount: (value: number) => void;
    decreasePeerCount: (value: number) => void;
    addPeer: (peerId: string, peer: INewPeerState) => void;
    removePeer: (peerId: string) => void;
    addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
    pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
    addReaction: (peerId: string, reaction: Reaction) => void;
    removeReaction: (peerId: string) => void;
    setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
    peers: {
        [peerId: string]: IPeerStoreState;
    };
    geo: string;
    initMe: (meInit: IMeInitState) => void;
    setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
    setGeo: (geo: string) => void;
    setAvatarUrl: (avatar: string) => void;
    addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
    removeProducerMedia: (producerType: MediaConsumerTypes) => void;
    updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
    toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
    toggleMeHandRaise: (isHandRaised: boolean) => void;
    addMeReaction: (reaction: Reaction) => void;
    rmMeReaction: () => void;
    peerId: string;
    displayName: string;
    avatarUrl: string;
    producers: MediaConsumerTracks;
    isMicPaused: boolean;
    isCamPaused: boolean;
    isSharePaused: boolean;
    isHandRaised: boolean;
    reaction: Reaction;
    gridView: GridViewTypes;
    screenSharePeerId?: string | null | undefined;
    setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
    enableScreenShare: (peerId: string) => void;
    disableScreenShare: (gridView: GridViewTypes) => void;
} | Partial<{
    peerDisplayName: string;
    setPeerDisplayName: (peerDisplayName: string | undefined) => void;
    layout: {
        type: ILayoutSchemaType;
    };
    setLayoutView: (type: ILayoutSchemaType) => void;
    dominantSpeaker: string;
    peerIdToVolume: Record<string, number>;
    addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
    removeStreamFromHark: (peerId: string) => void;
    micState: {
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
    };
    audioDevices: MediaDeviceInfo[];
    enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setAudioDevice: (device: MediaDeviceInfo) => void;
    getAudioDevices: () => Promise<MediaDeviceInfo[]>;
    setAudioStream: (stream: MediaStream | null) => void;
    pauseAudioTracks: () => void;
    switchAudioStream: (stream: MediaStream | null) => void;
    setAudioDeviceLoading: (loading: boolean) => void;
    setAudioStreamError: (error: string) => void;
    activeSpeaker: MediaDeviceInfo | null;
    setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
    streamData: {
        youtube?: IStreamData | undefined;
        livepeer?: IStreamData | undefined;
        twitch?: IStreamData | undefined;
    };
    isLiveStreaming: boolean;
    livePlatform: IStreamingPlatform;
    setPlatform: (platform: IStreamingPlatform) => void;
    startStreaming: (platform: IStreamingPlatform) => void;
    stopStreaming: (platform: IStreamingPlatform) => void;
    setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
    removeStreamData: (platform: IStreamingPlatform) => void;
    hostId: string | null;
    hostState: IHostState;
    meId: string;
    coHosts: string[];
    hostControl: THostControls;
    setHost: (hostId: string) => void;
    setCoHosts: (coHosts: string[]) => void;
    setHostState: (hostState: IHostState) => void;
    setHostControl: (control: THostControls) => void;
    setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
    initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
    networkStats: TNetStats;
    bandwidthSaver: boolean;
    setBandwidthSaver: (value: boolean) => void;
    setNetworkStats: (networkStats: TNetStats) => void;
    roomState: IRoomState;
    setRoomLockState: (isRoomLocked: boolean) => void;
    setRoomId: (roomId: string) => void;
    setJoined: () => void;
    setDropState: (dropReason: IDropReason) => void;
    setCreatedAt: (createdAt: number) => void;
    lobbyPeers: ILobbyPeer[];
    addLobbyPeer: (peer: ILobbyPeer) => void;
    setLobbyPeers: (peers: ILobbyPeer[]) => void;
    unread: {
        [chatRoomId: string]: number;
    };
    chat: {
        [chatRoomId: string]: IChatMessage[];
    };
    reactions: {
        [peerId: string]: string;
    };
    sharedFilesArr: TSharedFile[];
    notificationSounds: TNotifSounds;
    chatNotif: boolean;
    peerJoinNotif: boolean;
    peerLeaveNotif: boolean;
    setchatNotif: (value: boolean) => void;
    setpeerJoinNotif: (value: boolean) => void;
    setpeerLeaveNotif: (value: boolean) => void;
    setNotificationSounds: (sounds: TNotifSounds) => void;
    setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
    removeChat: (toId: string) => void;
    increaseUnread: (chatRoomId: string) => void;
    removeUnread: (chatRoomId: string) => void;
    addSharedFile: (file: TSharedFile) => void;
    setSharedFiles: (sharedFiles: TSharedFile[]) => void;
    recordingState: {
        inProgress: boolean;
        processing: boolean;
        started: boolean;
    };
    uploadToIpfs: boolean;
    recordings: IRecordingType[];
    newRecording: IRecordingType | null;
    notifyRecording: {
        started: boolean;
        finished: boolean;
    };
    startRecording: () => void;
    toggleRecording: (started: boolean) => void;
    stopRecording: () => void;
    updateRecordings: (recording: IRecordingType) => void;
    setRecordings: (recordings: IRecordingType[]) => void;
    removeNewrecording: () => void;
    endRecording: () => void;
    setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
    isFigmentEnabled: boolean;
    figment: {
        figmentType: "video" | "blur" | "image" | "enable";
        figmentStream: MediaStream | null;
        figmentLoading: boolean;
        figmentstreamError: {
            type: string;
            blocked: boolean;
        } | null;
    };
    setFigmentEnabled: (isFigmentEnabled: boolean) => void;
    toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
    setFigmentStream: (stream: MediaStream) => void;
    toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
    enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
    disableFigmentStream: () => void;
    setFigmentStreamError: (error: string) => void;
    initFigmentStream: () => Promise<void>;
    mediaDevice: MediaDeviceInfo | null;
    stream: MediaStream | null;
    streamError: {
        type: string;
        blocked: boolean;
    } | null;
    deviceLoading: boolean;
    streamsArry: MediaStream[];
    enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setMediaDevice: (device: MediaDeviceInfo) => void;
    getMediaDevices: () => Promise<MediaDeviceInfo[]>;
    setMediaStream: (stream: MediaStream | null) => void;
    pauseTracks: () => void;
    switchMediaStream: (stream: MediaStream | null) => void;
    setDeviceLoading: (loading: boolean) => void;
    setStreamError: (error: string) => void;
    maxViewPortCount: number;
    activeViewPort: number;
    isLastNActive: boolean;
    lastNPeerIds: string[];
    getTotalNumberOfSwaps: (newLastN: string[]) => number;
    setLastNPeerIds: (lastNPeerIds: string[]) => void;
    addPeerToLastN: (peerId: string) => void;
    removePeerFromLastN: (peerId: string) => void;
    activateLastN: () => void;
    deactivateLastN: () => void;
    addActiveViewPort: (value?: number | undefined) => void;
    removeActiveViewPort: (value?: number | undefined) => void;
    isTest: boolean;
    toggleIsTest: () => void;
    peerCount: number;
    increasePeerCount: (value: number) => void;
    decreasePeerCount: (value: number) => void;
    addPeer: (peerId: string, peer: INewPeerState) => void;
    removePeer: (peerId: string) => void;
    addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
    pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
    addReaction: (peerId: string, reaction: Reaction) => void;
    removeReaction: (peerId: string) => void;
    setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
    peers: {
        [peerId: string]: IPeerStoreState;
    };
    geo: string;
    initMe: (meInit: IMeInitState) => void;
    setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
    setGeo: (geo: string) => void;
    setAvatarUrl: (avatar: string) => void;
    addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
    removeProducerMedia: (producerType: MediaConsumerTypes) => void;
    updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
    toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
    toggleMeHandRaise: (isHandRaised: boolean) => void;
    addMeReaction: (reaction: Reaction) => void;
    rmMeReaction: () => void;
    peerId: string;
    displayName: string;
    avatarUrl: string;
    producers: MediaConsumerTracks;
    isMicPaused: boolean;
    isCamPaused: boolean;
    isSharePaused: boolean;
    isHandRaised: boolean;
    reaction: Reaction;
    gridView: GridViewTypes;
    screenSharePeerId?: string | null | undefined;
    setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
    enableScreenShare: (peerId: string) => void;
    disableScreenShare: (gridView: GridViewTypes) => void;
}> | ((state: {
    peerDisplayName: string;
    setPeerDisplayName: (peerDisplayName: string | undefined) => void;
    layout: {
        type: ILayoutSchemaType;
    };
    setLayoutView: (type: ILayoutSchemaType) => void;
    dominantSpeaker: string;
    peerIdToVolume: Record<string, number>;
    addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
    removeStreamFromHark: (peerId: string) => void;
    micState: {
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
    };
    audioDevices: MediaDeviceInfo[];
    enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setAudioDevice: (device: MediaDeviceInfo) => void;
    getAudioDevices: () => Promise<MediaDeviceInfo[]>;
    setAudioStream: (stream: MediaStream | null) => void;
    pauseAudioTracks: () => void;
    switchAudioStream: (stream: MediaStream | null) => void;
    setAudioDeviceLoading: (loading: boolean) => void;
    setAudioStreamError: (error: string) => void;
    activeSpeaker: MediaDeviceInfo | null;
    setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
    streamData: {
        youtube?: IStreamData | undefined;
        livepeer?: IStreamData | undefined;
        twitch?: IStreamData | undefined;
    };
    isLiveStreaming: boolean;
    livePlatform: IStreamingPlatform;
    setPlatform: (platform: IStreamingPlatform) => void;
    startStreaming: (platform: IStreamingPlatform) => void;
    stopStreaming: (platform: IStreamingPlatform) => void;
    setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
    removeStreamData: (platform: IStreamingPlatform) => void;
    hostId: string | null;
    hostState: IHostState;
    meId: string;
    coHosts: string[];
    hostControl: THostControls;
    setHost: (hostId: string) => void;
    setCoHosts: (coHosts: string[]) => void;
    setHostState: (hostState: IHostState) => void;
    setHostControl: (control: THostControls) => void;
    setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
    initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
    networkStats: TNetStats;
    bandwidthSaver: boolean;
    setBandwidthSaver: (value: boolean) => void;
    setNetworkStats: (networkStats: TNetStats) => void;
    roomState: IRoomState;
    setRoomLockState: (isRoomLocked: boolean) => void;
    setRoomId: (roomId: string) => void;
    setJoined: () => void;
    setDropState: (dropReason: IDropReason) => void;
    setCreatedAt: (createdAt: number) => void;
    lobbyPeers: ILobbyPeer[];
    addLobbyPeer: (peer: ILobbyPeer) => void;
    setLobbyPeers: (peers: ILobbyPeer[]) => void;
    unread: {
        [chatRoomId: string]: number;
    };
    chat: {
        [chatRoomId: string]: IChatMessage[];
    };
    reactions: {
        [peerId: string]: string;
    };
    sharedFilesArr: TSharedFile[];
    notificationSounds: TNotifSounds;
    chatNotif: boolean;
    peerJoinNotif: boolean;
    peerLeaveNotif: boolean;
    setchatNotif: (value: boolean) => void;
    setpeerJoinNotif: (value: boolean) => void;
    setpeerLeaveNotif: (value: boolean) => void;
    setNotificationSounds: (sounds: TNotifSounds) => void;
    setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
    removeChat: (toId: string) => void;
    increaseUnread: (chatRoomId: string) => void;
    removeUnread: (chatRoomId: string) => void;
    addSharedFile: (file: TSharedFile) => void;
    setSharedFiles: (sharedFiles: TSharedFile[]) => void;
    recordingState: {
        inProgress: boolean;
        processing: boolean;
        started: boolean;
    };
    uploadToIpfs: boolean;
    recordings: IRecordingType[];
    newRecording: IRecordingType | null;
    notifyRecording: {
        started: boolean;
        finished: boolean;
    };
    startRecording: () => void;
    toggleRecording: (started: boolean) => void;
    stopRecording: () => void;
    updateRecordings: (recording: IRecordingType) => void;
    setRecordings: (recordings: IRecordingType[]) => void;
    removeNewrecording: () => void;
    endRecording: () => void;
    setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
    isFigmentEnabled: boolean;
    figment: {
        figmentType: "video" | "blur" | "image" | "enable";
        figmentStream: MediaStream | null;
        figmentLoading: boolean;
        figmentstreamError: {
            type: string;
            blocked: boolean;
        } | null;
    };
    setFigmentEnabled: (isFigmentEnabled: boolean) => void;
    toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
    setFigmentStream: (stream: MediaStream) => void;
    toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
    enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
    disableFigmentStream: () => void;
    setFigmentStreamError: (error: string) => void;
    initFigmentStream: () => Promise<void>;
    mediaDevice: MediaDeviceInfo | null;
    stream: MediaStream | null;
    streamError: {
        type: string;
        blocked: boolean;
    } | null;
    deviceLoading: boolean;
    streamsArry: MediaStream[];
    enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setMediaDevice: (device: MediaDeviceInfo) => void;
    getMediaDevices: () => Promise<MediaDeviceInfo[]>;
    setMediaStream: (stream: MediaStream | null) => void;
    pauseTracks: () => void;
    switchMediaStream: (stream: MediaStream | null) => void;
    setDeviceLoading: (loading: boolean) => void;
    setStreamError: (error: string) => void;
    maxViewPortCount: number;
    activeViewPort: number;
    isLastNActive: boolean;
    lastNPeerIds: string[];
    getTotalNumberOfSwaps: (newLastN: string[]) => number;
    setLastNPeerIds: (lastNPeerIds: string[]) => void;
    addPeerToLastN: (peerId: string) => void;
    removePeerFromLastN: (peerId: string) => void;
    activateLastN: () => void;
    deactivateLastN: () => void;
    addActiveViewPort: (value?: number | undefined) => void;
    removeActiveViewPort: (value?: number | undefined) => void;
    isTest: boolean;
    toggleIsTest: () => void;
    peerCount: number;
    increasePeerCount: (value: number) => void;
    decreasePeerCount: (value: number) => void;
    addPeer: (peerId: string, peer: INewPeerState) => void;
    removePeer: (peerId: string) => void;
    addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
    pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
    addReaction: (peerId: string, reaction: Reaction) => void;
    removeReaction: (peerId: string) => void;
    setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
    peers: {
        [peerId: string]: IPeerStoreState;
    };
    geo: string;
    initMe: (meInit: IMeInitState) => void;
    setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
    setGeo: (geo: string) => void;
    setAvatarUrl: (avatar: string) => void;
    addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
    removeProducerMedia: (producerType: MediaConsumerTypes) => void;
    updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
    toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
    toggleMeHandRaise: (isHandRaised: boolean) => void;
    addMeReaction: (reaction: Reaction) => void;
    rmMeReaction: () => void;
    peerId: string;
    displayName: string;
    avatarUrl: string;
    producers: MediaConsumerTracks;
    isMicPaused: boolean;
    isCamPaused: boolean;
    isSharePaused: boolean;
    isHandRaised: boolean;
    reaction: Reaction;
    gridView: GridViewTypes;
    screenSharePeerId?: string | null | undefined;
    setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
    enableScreenShare: (peerId: string) => void;
    disableScreenShare: (gridView: GridViewTypes) => void;
}) => {
    peerDisplayName: string;
    setPeerDisplayName: (peerDisplayName: string | undefined) => void;
    layout: {
        type: ILayoutSchemaType;
    };
    setLayoutView: (type: ILayoutSchemaType) => void;
    dominantSpeaker: string;
    peerIdToVolume: Record<string, number>;
    addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
    removeStreamFromHark: (peerId: string) => void;
    micState: {
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
    };
    audioDevices: MediaDeviceInfo[];
    enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setAudioDevice: (device: MediaDeviceInfo) => void;
    getAudioDevices: () => Promise<MediaDeviceInfo[]>;
    setAudioStream: (stream: MediaStream | null) => void;
    pauseAudioTracks: () => void;
    switchAudioStream: (stream: MediaStream | null) => void;
    setAudioDeviceLoading: (loading: boolean) => void;
    setAudioStreamError: (error: string) => void;
    activeSpeaker: MediaDeviceInfo | null;
    setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
    streamData: {
        youtube?: IStreamData | undefined;
        livepeer?: IStreamData | undefined;
        twitch?: IStreamData | undefined;
    };
    isLiveStreaming: boolean;
    livePlatform: IStreamingPlatform;
    setPlatform: (platform: IStreamingPlatform) => void;
    startStreaming: (platform: IStreamingPlatform) => void;
    stopStreaming: (platform: IStreamingPlatform) => void;
    setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
    removeStreamData: (platform: IStreamingPlatform) => void;
    hostId: string | null;
    hostState: IHostState;
    meId: string;
    coHosts: string[];
    hostControl: THostControls;
    setHost: (hostId: string) => void;
    setCoHosts: (coHosts: string[]) => void;
    setHostState: (hostState: IHostState) => void;
    setHostControl: (control: THostControls) => void;
    setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
    initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
    networkStats: TNetStats;
    bandwidthSaver: boolean;
    setBandwidthSaver: (value: boolean) => void;
    setNetworkStats: (networkStats: TNetStats) => void;
    roomState: IRoomState;
    setRoomLockState: (isRoomLocked: boolean) => void;
    setRoomId: (roomId: string) => void;
    setJoined: () => void;
    setDropState: (dropReason: IDropReason) => void;
    setCreatedAt: (createdAt: number) => void;
    lobbyPeers: ILobbyPeer[];
    addLobbyPeer: (peer: ILobbyPeer) => void;
    setLobbyPeers: (peers: ILobbyPeer[]) => void;
    unread: {
        [chatRoomId: string]: number;
    };
    chat: {
        [chatRoomId: string]: IChatMessage[];
    };
    reactions: {
        [peerId: string]: string;
    };
    sharedFilesArr: TSharedFile[];
    notificationSounds: TNotifSounds;
    chatNotif: boolean;
    peerJoinNotif: boolean;
    peerLeaveNotif: boolean;
    setchatNotif: (value: boolean) => void;
    setpeerJoinNotif: (value: boolean) => void;
    setpeerLeaveNotif: (value: boolean) => void;
    setNotificationSounds: (sounds: TNotifSounds) => void;
    setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
    removeChat: (toId: string) => void;
    increaseUnread: (chatRoomId: string) => void;
    removeUnread: (chatRoomId: string) => void;
    addSharedFile: (file: TSharedFile) => void;
    setSharedFiles: (sharedFiles: TSharedFile[]) => void;
    recordingState: {
        inProgress: boolean;
        processing: boolean;
        started: boolean;
    };
    uploadToIpfs: boolean;
    recordings: IRecordingType[];
    newRecording: IRecordingType | null;
    notifyRecording: {
        started: boolean;
        finished: boolean;
    };
    startRecording: () => void;
    toggleRecording: (started: boolean) => void;
    stopRecording: () => void;
    updateRecordings: (recording: IRecordingType) => void;
    setRecordings: (recordings: IRecordingType[]) => void;
    removeNewrecording: () => void;
    endRecording: () => void;
    setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
    isFigmentEnabled: boolean;
    figment: {
        figmentType: "video" | "blur" | "image" | "enable";
        figmentStream: MediaStream | null;
        figmentLoading: boolean;
        figmentstreamError: {
            type: string;
            blocked: boolean;
        } | null;
    };
    setFigmentEnabled: (isFigmentEnabled: boolean) => void;
    toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
    setFigmentStream: (stream: MediaStream) => void;
    toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
    enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
    disableFigmentStream: () => void;
    setFigmentStreamError: (error: string) => void;
    initFigmentStream: () => Promise<void>;
    mediaDevice: MediaDeviceInfo | null;
    stream: MediaStream | null;
    streamError: {
        type: string;
        blocked: boolean;
    } | null;
    deviceLoading: boolean;
    streamsArry: MediaStream[];
    enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setMediaDevice: (device: MediaDeviceInfo) => void;
    getMediaDevices: () => Promise<MediaDeviceInfo[]>;
    setMediaStream: (stream: MediaStream | null) => void;
    pauseTracks: () => void;
    switchMediaStream: (stream: MediaStream | null) => void;
    setDeviceLoading: (loading: boolean) => void;
    setStreamError: (error: string) => void;
    maxViewPortCount: number;
    activeViewPort: number;
    isLastNActive: boolean;
    lastNPeerIds: string[];
    getTotalNumberOfSwaps: (newLastN: string[]) => number;
    setLastNPeerIds: (lastNPeerIds: string[]) => void;
    addPeerToLastN: (peerId: string) => void;
    removePeerFromLastN: (peerId: string) => void;
    activateLastN: () => void;
    deactivateLastN: () => void;
    addActiveViewPort: (value?: number | undefined) => void;
    removeActiveViewPort: (value?: number | undefined) => void;
    isTest: boolean;
    toggleIsTest: () => void;
    peerCount: number;
    increasePeerCount: (value: number) => void;
    decreasePeerCount: (value: number) => void;
    addPeer: (peerId: string, peer: INewPeerState) => void;
    removePeer: (peerId: string) => void;
    addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
    pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
    addReaction: (peerId: string, reaction: Reaction) => void;
    removeReaction: (peerId: string) => void;
    setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
    peers: {
        [peerId: string]: IPeerStoreState;
    };
    geo: string;
    initMe: (meInit: IMeInitState) => void;
    setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
    setGeo: (geo: string) => void;
    setAvatarUrl: (avatar: string) => void;
    addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
    removeProducerMedia: (producerType: MediaConsumerTypes) => void;
    updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
    toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
    toggleMeHandRaise: (isHandRaised: boolean) => void;
    addMeReaction: (reaction: Reaction) => void;
    rmMeReaction: () => void;
    peerId: string;
    displayName: string;
    avatarUrl: string;
    producers: MediaConsumerTracks;
    isMicPaused: boolean;
    isCamPaused: boolean;
    isSharePaused: boolean;
    isHandRaised: boolean;
    reaction: Reaction;
    gridView: GridViewTypes;
    screenSharePeerId?: string | null | undefined;
    setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
    enableScreenShare: (peerId: string) => void;
    disableScreenShare: (gridView: GridViewTypes) => void;
} | Partial<{
    peerDisplayName: string;
    setPeerDisplayName: (peerDisplayName: string | undefined) => void;
    layout: {
        type: ILayoutSchemaType;
    };
    setLayoutView: (type: ILayoutSchemaType) => void;
    dominantSpeaker: string;
    peerIdToVolume: Record<string, number>;
    addStreamToHark: (stream: MediaStreamTrack, peerId: string) => void;
    removeStreamFromHark: (peerId: string) => void;
    micState: {
        mediaDevice: MediaDeviceInfo | null;
        stream: MediaStream | null;
        streamError: {
            type: string;
            blocked: boolean;
        } | null;
        deviceLoading: boolean;
    };
    audioDevices: MediaDeviceInfo[];
    enableAudioStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setAudioDevice: (device: MediaDeviceInfo) => void;
    getAudioDevices: () => Promise<MediaDeviceInfo[]>;
    setAudioStream: (stream: MediaStream | null) => void;
    pauseAudioTracks: () => void;
    switchAudioStream: (stream: MediaStream | null) => void;
    setAudioDeviceLoading: (loading: boolean) => void;
    setAudioStreamError: (error: string) => void;
    activeSpeaker: MediaDeviceInfo | null;
    setActiveSpeaker: (activeSpeaker: MediaDeviceInfo) => void;
    streamData: {
        youtube?: IStreamData | undefined;
        livepeer?: IStreamData | undefined;
        twitch?: IStreamData | undefined;
    };
    isLiveStreaming: boolean;
    livePlatform: IStreamingPlatform;
    setPlatform: (platform: IStreamingPlatform) => void;
    startStreaming: (platform: IStreamingPlatform) => void;
    stopStreaming: (platform: IStreamingPlatform) => void;
    setStreamData: (platform: IStreamingPlatform, streamData: IStreamData) => void;
    removeStreamData: (platform: IStreamingPlatform) => void;
    hostId: string | null;
    hostState: IHostState;
    meId: string;
    coHosts: string[];
    hostControl: THostControls;
    setHost: (hostId: string) => void;
    setCoHosts: (coHosts: string[]) => void;
    setHostState: (hostState: IHostState) => void;
    setHostControl: (control: THostControls) => void;
    setSingleHostControl: (control: keyof THostControls, val: boolean) => void;
    initHostControls: (hostId: string, meId: string, hostControl: THostControls, coHostIds?: string[] | undefined) => void;
    networkStats: TNetStats;
    bandwidthSaver: boolean;
    setBandwidthSaver: (value: boolean) => void;
    setNetworkStats: (networkStats: TNetStats) => void;
    roomState: IRoomState;
    setRoomLockState: (isRoomLocked: boolean) => void;
    setRoomId: (roomId: string) => void;
    setJoined: () => void;
    setDropState: (dropReason: IDropReason) => void;
    setCreatedAt: (createdAt: number) => void;
    lobbyPeers: ILobbyPeer[];
    addLobbyPeer: (peer: ILobbyPeer) => void;
    setLobbyPeers: (peers: ILobbyPeer[]) => void;
    unread: {
        [chatRoomId: string]: number;
    };
    chat: {
        [chatRoomId: string]: IChatMessage[];
    };
    reactions: {
        [peerId: string]: string;
    };
    sharedFilesArr: TSharedFile[];
    notificationSounds: TNotifSounds;
    chatNotif: boolean;
    peerJoinNotif: boolean;
    peerLeaveNotif: boolean;
    setchatNotif: (value: boolean) => void;
    setpeerJoinNotif: (value: boolean) => void;
    setpeerLeaveNotif: (value: boolean) => void;
    setNotificationSounds: (sounds: TNotifSounds) => void;
    setChat: (chat: IChatText, toId: string, err?: IChatErrorType | undefined) => void;
    removeChat: (toId: string) => void;
    increaseUnread: (chatRoomId: string) => void;
    removeUnread: (chatRoomId: string) => void;
    addSharedFile: (file: TSharedFile) => void;
    setSharedFiles: (sharedFiles: TSharedFile[]) => void;
    recordingState: {
        inProgress: boolean;
        processing: boolean;
        started: boolean;
    };
    uploadToIpfs: boolean;
    recordings: IRecordingType[];
    newRecording: IRecordingType | null;
    notifyRecording: {
        started: boolean;
        finished: boolean;
    };
    startRecording: () => void;
    toggleRecording: (started: boolean) => void;
    stopRecording: () => void;
    updateRecordings: (recording: IRecordingType) => void;
    setRecordings: (recordings: IRecordingType[]) => void;
    removeNewrecording: () => void;
    endRecording: () => void;
    setNotifyRecording: (key: "started" | "finished", value: boolean) => void;
    isFigmentEnabled: boolean;
    figment: {
        figmentType: "video" | "blur" | "image" | "enable";
        figmentStream: MediaStream | null;
        figmentLoading: boolean;
        figmentstreamError: {
            type: string;
            blocked: boolean;
        } | null;
    };
    setFigmentEnabled: (isFigmentEnabled: boolean) => void;
    toggleFigmentType: (figmentType: "video" | "blur" | "image") => void;
    setFigmentStream: (stream: MediaStream) => void;
    toggleFigmentStream: (streamState: "enable" | "disable" | "switch") => Promise<void>;
    enableFigmentCamStream: (mediaDevice?: MediaDeviceInfo | undefined) => Promise<void>;
    disableFigmentStream: () => void;
    setFigmentStreamError: (error: string) => void;
    initFigmentStream: () => Promise<void>;
    mediaDevice: MediaDeviceInfo | null;
    stream: MediaStream | null;
    streamError: {
        type: string;
        blocked: boolean;
    } | null;
    deviceLoading: boolean;
    streamsArry: MediaStream[];
    enableStream: (constraints?: MediaStreamConstraints | undefined) => Promise<void>;
    setMediaDevice: (device: MediaDeviceInfo) => void;
    getMediaDevices: () => Promise<MediaDeviceInfo[]>;
    setMediaStream: (stream: MediaStream | null) => void;
    pauseTracks: () => void;
    switchMediaStream: (stream: MediaStream | null) => void;
    setDeviceLoading: (loading: boolean) => void;
    setStreamError: (error: string) => void;
    maxViewPortCount: number;
    activeViewPort: number;
    isLastNActive: boolean;
    lastNPeerIds: string[];
    getTotalNumberOfSwaps: (newLastN: string[]) => number;
    setLastNPeerIds: (lastNPeerIds: string[]) => void;
    addPeerToLastN: (peerId: string) => void;
    removePeerFromLastN: (peerId: string) => void;
    activateLastN: () => void;
    deactivateLastN: () => void;
    addActiveViewPort: (value?: number | undefined) => void;
    removeActiveViewPort: (value?: number | undefined) => void;
    isTest: boolean;
    toggleIsTest: () => void;
    peerCount: number;
    increasePeerCount: (value: number) => void;
    decreasePeerCount: (value: number) => void;
    addPeer: (peerId: string, peer: INewPeerState) => void;
    removePeer: (peerId: string) => void;
    addConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes, consumer: MediaConsumer) => void;
    pauseConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    resumeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    removeConsumerMedia: (peerId: string, consumerType: MediaConsumerTypes) => void;
    togglePeerHandRaise: (peerId: string, isHandRaised: boolean) => void;
    addReaction: (peerId: string, reaction: Reaction) => void;
    removeReaction: (peerId: string) => void;
    setPeerAvatarUrl: (peerId: string, avatarUrl: string) => void;
    peers: {
        [peerId: string]: IPeerStoreState;
    };
    geo: string;
    initMe: (meInit: IMeInitState) => void;
    setMe: (consumerType: IMeStoreStateKeys, value: any) => void;
    setGeo: (geo: string) => void;
    setAvatarUrl: (avatar: string) => void;
    addProducerMedia: (producerType: MediaConsumerTypes, producer: MediaConsumer) => void;
    removeProducerMedia: (producerType: MediaConsumerTypes) => void;
    updateProducerMedia(producerType: MediaConsumerTypes, producer: MediaConsumer): void;
    toggleProducerMedia: (producerType: MediaConsumerTypes, value: IDeviceSwitch) => void;
    toggleMeHandRaise: (isHandRaised: boolean) => void;
    addMeReaction: (reaction: Reaction) => void;
    rmMeReaction: () => void;
    peerId: string;
    displayName: string;
    avatarUrl: string;
    producers: MediaConsumerTracks;
    isMicPaused: boolean;
    isCamPaused: boolean;
    isSharePaused: boolean;
    isHandRaised: boolean;
    reaction: Reaction;
    gridView: GridViewTypes;
    screenSharePeerId?: string | null | undefined;
    setGridView: (gridView: GridViewTypes, peerId?: string | undefined) => void;
    enableScreenShare: (peerId: string) => void;
    disableScreenShare: (gridView: GridViewTypes) => void;
}>), replace?: boolean | undefined, actionType?: string | {
    type: unknown;
} | undefined) => void;

export { store as default, getState, setState, useHuddleStore, useRootStore };
