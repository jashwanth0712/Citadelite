/// <reference types="node" />
import { BytesLike } from '@ethersproject/bytes';
import { AppProps, HashFunctionOutput, VerificationRequest } from './types';
import WalletConnect from '@walletconnect/client';
/**
 * Generates a random integer between a specified range
 * @param min Minimum number in range (inclusive)
 * @param max Maximum number in range (inclusive)
 * @returns Number between range
 */
export declare const randomNumber: (min: number, max: number) => number;
export declare const buildVerificationRequest: (props: AppProps) => VerificationRequest;
/**
 * Verifies that the response from the WLD app is valid
 * @param result expects a valid `VerificationResponse`
 */
export declare const verifyVerificationResponse: (result: Record<string, string | undefined>) => boolean;
/**
 * Validates that an string looks like an ABI-encoded string. Very basic format-like check.
 * The WLD app validates the actual values.
 * @param value string to validate
 * @returns `true` if the value looks like an ABI-encoded string; `false` otherwise
 */
export declare const validateABILikeEncoding: (value: string) => boolean;
/**
 * Validates the input parameters passed to the package when initializing.
 * @param params `AppProps`
 * @returns `true` if parameters are valid; error is raised otherwise.
 */
export declare const validateInputParams: (params: AppProps) => {
    valid: boolean;
    error?: string;
};
/**
 * Hashes an input using the `keccak256` hashing function used across the World ID protocol, to be used as
 * a ZKP input. The function will try to determine the best hashing mechanism, if the string already looks like hex-encoded
 * bytes (e.g. `0x0000000000000000000000000000000000000000`), it will be hashed directly.
 * @param input Any string, hex-like string, bytes represented as a hex string.
 * @returns
 */
export declare function worldIDHash(input: BytesLike | Buffer): HashFunctionOutput;
/**
 * Using `worldIDHash` is recommended! Use this if you're certain you want to hash a string.
 * Converts an input to bytes and then hashes it with the World ID protocol hashing function.
 * @param input - String to hash
 * @returns hash
 */
export declare function hashString(input: string): HashFunctionOutput;
/**
 * Using `worldIDHash` is recommended! Use this if you're certain you want to hash raw bytes.
 * Hashes raw bytes input using the `keccak256` hashing function used across the World ID protocol, to be used as
 * a ZKP input. Example use cases include when you're hashing an address to be verified in a smart contract.
 * @param input - Bytes represented as a hex string.
 * @returns
 */
export declare function hashEncodedBytes(input: BytesLike): HashFunctionOutput;
/**
 * Partial implementation of `keccak256` hash from @ethersproject/solidity; only supports hashing a single BytesLike value
 * @param value value to hash
 * @returns
 */
export declare function keccak256(value: BytesLike): string;
/**
 * Build data for QR Code
 * @param connector WalletConnect connection instance
 * @returns string
 */
export declare function buildQRData(connector: WalletConnect, returnUrl?: string): string;
